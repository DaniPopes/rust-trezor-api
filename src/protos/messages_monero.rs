// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-monero.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

/// *
///  Structure representing Monero transaction source entry, UTXO
///  @embed
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
pub struct MoneroTransactionSourceEntry {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
    pub outputs: ::std::vec::Vec<monero_transaction_source_entry::MoneroOutputEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
    pub real_output: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
    pub real_out_tx_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
    pub real_out_additional_tx_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
    pub real_output_in_tx_index: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
    pub amount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
    pub rct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
    pub mask: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
    pub multisig_kLRki: ::protobuf::MessageField<monero_transaction_source_entry::MoneroMultisigKLRki>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry {
    fn default() -> &'a MoneroTransactionSourceEntry {
        <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry {
    pub fn new() -> MoneroTransactionSourceEntry {
        ::std::default::Default::default()
    }

    // optional uint64 real_output = 2;

    pub fn real_output(&self) -> u64 {
        self.real_output.unwrap_or(0)
    }

    pub fn clear_real_output(&mut self) {
        self.real_output = ::std::option::Option::None;
    }

    pub fn has_real_output(&self) -> bool {
        self.real_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output(&mut self, v: u64) {
        self.real_output = ::std::option::Option::Some(v);
    }

    // optional bytes real_out_tx_key = 3;

    pub fn real_out_tx_key(&self) -> &[u8] {
        match self.real_out_tx_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_real_out_tx_key(&mut self) {
        self.real_out_tx_key = ::std::option::Option::None;
    }

    pub fn has_real_out_tx_key(&self) -> bool {
        self.real_out_tx_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_tx_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.real_out_tx_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_out_tx_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.real_out_tx_key.is_none() {
            self.real_out_tx_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.real_out_tx_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_out_tx_key(&mut self) -> ::std::vec::Vec<u8> {
        self.real_out_tx_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 real_output_in_tx_index = 5;

    pub fn real_output_in_tx_index(&self) -> u64 {
        self.real_output_in_tx_index.unwrap_or(0)
    }

    pub fn clear_real_output_in_tx_index(&mut self) {
        self.real_output_in_tx_index = ::std::option::Option::None;
    }

    pub fn has_real_output_in_tx_index(&self) -> bool {
        self.real_output_in_tx_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output_in_tx_index(&mut self, v: u64) {
        self.real_output_in_tx_index = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;

    pub fn amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool rct = 7;

    pub fn rct(&self) -> bool {
        self.rct.unwrap_or(false)
    }

    pub fn clear_rct(&mut self) {
        self.rct = ::std::option::Option::None;
    }

    pub fn has_rct(&self) -> bool {
        self.rct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rct(&mut self, v: bool) {
        self.rct = ::std::option::Option::Some(v);
    }

    // optional bytes mask = 8;

    pub fn mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MoneroTransactionSourceEntry| { &m.outputs },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_output",
            |m: &MoneroTransactionSourceEntry| { &m.real_output },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_out_tx_key",
            |m: &MoneroTransactionSourceEntry| { &m.real_out_tx_key },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_tx_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "real_out_additional_tx_keys",
            |m: &MoneroTransactionSourceEntry| { &m.real_out_additional_tx_keys },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_additional_tx_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_output_in_tx_index",
            |m: &MoneroTransactionSourceEntry| { &m.real_output_in_tx_index },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output_in_tx_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &MoneroTransactionSourceEntry| { &m.amount },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rct",
            |m: &MoneroTransactionSourceEntry| { &m.rct },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.rct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mask",
            |m: &MoneroTransactionSourceEntry| { &m.mask },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_source_entry::MoneroMultisigKLRki>(
            "multisig_kLRki",
            |m: &MoneroTransactionSourceEntry| { &m.multisig_kLRki },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.multisig_kLRki },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSourceEntry>(
            "MoneroTransactionSourceEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry {
    const NAME: &'static str = "MoneroTransactionSourceEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.outputs.push(is.read_message()?);
                },
                16 => {
                    self.real_output = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.real_out_tx_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.real_out_additional_tx_keys.push(is.read_bytes()?);
                },
                40 => {
                    self.real_output_in_tx_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.amount = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.rct = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.mask = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.multisig_kLRki)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.real_output {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.real_out_tx_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.real_out_additional_tx_keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.real_output_in_tx_index {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.rct {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.multisig_kLRki.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.real_output {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.real_out_tx_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        for v in &self.real_out_additional_tx_keys {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.real_output_in_tx_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.rct {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.mask.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.multisig_kLRki.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSourceEntry {
        MoneroTransactionSourceEntry::new()
    }

    fn clear(&mut self) {
        self.outputs.clear();
        self.real_output = ::std::option::Option::None;
        self.real_out_tx_key = ::std::option::Option::None;
        self.real_out_additional_tx_keys.clear();
        self.real_output_in_tx_index = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rct = ::std::option::Option::None;
        self.mask = ::std::option::Option::None;
        self.multisig_kLRki.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry {
        static instance: MoneroTransactionSourceEntry = MoneroTransactionSourceEntry {
            outputs: ::std::vec::Vec::new(),
            real_output: ::std::option::Option::None,
            real_out_tx_key: ::std::option::Option::None,
            real_out_additional_tx_keys: ::std::vec::Vec::new(),
            real_output_in_tx_index: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            rct: ::std::option::Option::None,
            mask: ::std::option::Option::None,
            multisig_kLRki: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSourceEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSourceEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionSourceEntry`
pub mod monero_transaction_source_entry {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
    pub struct MoneroOutputEntry {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
        pub idx: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
        pub key: ::protobuf::MessageField<monero_output_entry::MoneroRctKey>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroOutputEntry {
        fn default() -> &'a MoneroOutputEntry {
            <MoneroOutputEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroOutputEntry {
        pub fn new() -> MoneroOutputEntry {
            ::std::default::Default::default()
        }

        // optional uint64 idx = 1;

        pub fn idx(&self) -> u64 {
            self.idx.unwrap_or(0)
        }

        pub fn clear_idx(&mut self) {
            self.idx = ::std::option::Option::None;
        }

        pub fn has_idx(&self) -> bool {
            self.idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idx(&mut self, v: u64) {
            self.idx = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "idx",
                |m: &MoneroOutputEntry| { &m.idx },
                |m: &mut MoneroOutputEntry| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_output_entry::MoneroRctKey>(
                "key",
                |m: &MoneroOutputEntry| { &m.key },
                |m: &mut MoneroOutputEntry| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroOutputEntry>(
                "MoneroTransactionSourceEntry.MoneroOutputEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroOutputEntry {
        const NAME: &'static str = "MoneroOutputEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.idx = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.idx {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.key.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.idx {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.key.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroOutputEntry {
            MoneroOutputEntry::new()
        }

        fn clear(&mut self) {
            self.idx = ::std::option::Option::None;
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroOutputEntry {
            static instance: MoneroOutputEntry = MoneroOutputEntry {
                idx: ::std::option::Option::None,
                key: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroOutputEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroOutputEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroOutputEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroOutputEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `MoneroOutputEntry`
    pub mod monero_output_entry {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey)
        pub struct MoneroRctKey {
            // message fields
            // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey.dest)
            pub dest: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey.mask)
            pub mask: ::std::option::Option<::std::vec::Vec<u8>>,
            // special fields
            // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MoneroRctKey {
            fn default() -> &'a MoneroRctKey {
                <MoneroRctKey as ::protobuf::Message>::default_instance()
            }
        }

        impl MoneroRctKey {
            pub fn new() -> MoneroRctKey {
                ::std::default::Default::default()
            }

            // optional bytes dest = 1;

            pub fn dest(&self) -> &[u8] {
                match self.dest.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_dest(&mut self) {
                self.dest = ::std::option::Option::None;
            }

            pub fn has_dest(&self) -> bool {
                self.dest.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
                self.dest = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.dest.is_none() {
                    self.dest = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.dest.as_mut().unwrap()
            }

            // Take field
            pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
                self.dest.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional bytes mask = 2;

            pub fn mask(&self) -> &[u8] {
                match self.mask.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_mask(&mut self) {
                self.mask = ::std::option::Option::None;
            }

            pub fn has_mask(&self) -> bool {
                self.mask.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
                self.mask = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.mask.is_none() {
                    self.mask = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.mask.as_mut().unwrap()
            }

            // Take field
            pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
                self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "dest",
                    |m: &MoneroRctKey| { &m.dest },
                    |m: &mut MoneroRctKey| { &mut m.dest },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "mask",
                    |m: &MoneroRctKey| { &m.mask },
                    |m: &mut MoneroRctKey| { &mut m.mask },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroRctKey>(
                    "MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MoneroRctKey {
            const NAME: &'static str = "MoneroRctKey";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.dest = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        18 => {
                            self.mask = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.dest.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                }
                if let Some(v) = self.mask.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.dest.as_ref() {
                    os.write_bytes(1, v)?;
                }
                if let Some(v) = self.mask.as_ref() {
                    os.write_bytes(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MoneroRctKey {
                MoneroRctKey::new()
            }

            fn clear(&mut self) {
                self.dest = ::std::option::Option::None;
                self.mask = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MoneroRctKey {
                static instance: MoneroRctKey = MoneroRctKey {
                    dest: ::std::option::Option::None,
                    mask: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MoneroRctKey {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MoneroRctKey {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MoneroRctKey {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
    pub struct MoneroMultisigKLRki {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
        pub K: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
        pub L: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
        pub R: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
        pub ki: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroMultisigKLRki {
        fn default() -> &'a MoneroMultisigKLRki {
            <MoneroMultisigKLRki as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroMultisigKLRki {
        pub fn new() -> MoneroMultisigKLRki {
            ::std::default::Default::default()
        }

        // optional bytes K = 1;

        pub fn K(&self) -> &[u8] {
            match self.K.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_K(&mut self) {
            self.K = ::std::option::Option::None;
        }

        pub fn has_K(&self) -> bool {
            self.K.is_some()
        }

        // Param is passed by value, moved
        pub fn set_K(&mut self, v: ::std::vec::Vec<u8>) {
            self.K = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_K(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.K.is_none() {
                self.K = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.K.as_mut().unwrap()
        }

        // Take field
        pub fn take_K(&mut self) -> ::std::vec::Vec<u8> {
            self.K.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes L = 2;

        pub fn L(&self) -> &[u8] {
            match self.L.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_L(&mut self) {
            self.L = ::std::option::Option::None;
        }

        pub fn has_L(&self) -> bool {
            self.L.is_some()
        }

        // Param is passed by value, moved
        pub fn set_L(&mut self, v: ::std::vec::Vec<u8>) {
            self.L = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_L(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.L.is_none() {
                self.L = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.L.as_mut().unwrap()
        }

        // Take field
        pub fn take_L(&mut self) -> ::std::vec::Vec<u8> {
            self.L.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes R = 3;

        pub fn R(&self) -> &[u8] {
            match self.R.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_R(&mut self) {
            self.R = ::std::option::Option::None;
        }

        pub fn has_R(&self) -> bool {
            self.R.is_some()
        }

        // Param is passed by value, moved
        pub fn set_R(&mut self, v: ::std::vec::Vec<u8>) {
            self.R = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_R(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.R.is_none() {
                self.R = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.R.as_mut().unwrap()
        }

        // Take field
        pub fn take_R(&mut self) -> ::std::vec::Vec<u8> {
            self.R.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes ki = 4;

        pub fn ki(&self) -> &[u8] {
            match self.ki.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_ki(&mut self) {
            self.ki = ::std::option::Option::None;
        }

        pub fn has_ki(&self) -> bool {
            self.ki.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ki(&mut self, v: ::std::vec::Vec<u8>) {
            self.ki = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ki(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.ki.is_none() {
                self.ki = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.ki.as_mut().unwrap()
        }

        // Take field
        pub fn take_ki(&mut self) -> ::std::vec::Vec<u8> {
            self.ki.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "K",
                |m: &MoneroMultisigKLRki| { &m.K },
                |m: &mut MoneroMultisigKLRki| { &mut m.K },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "L",
                |m: &MoneroMultisigKLRki| { &m.L },
                |m: &mut MoneroMultisigKLRki| { &mut m.L },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "R",
                |m: &MoneroMultisigKLRki| { &m.R },
                |m: &mut MoneroMultisigKLRki| { &mut m.R },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ki",
                |m: &MoneroMultisigKLRki| { &m.ki },
                |m: &mut MoneroMultisigKLRki| { &mut m.ki },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroMultisigKLRki>(
                "MoneroTransactionSourceEntry.MoneroMultisigKLRki",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroMultisigKLRki {
        const NAME: &'static str = "MoneroMultisigKLRki";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.K = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.L = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.R = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.ki = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.K.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.L.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.R.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.ki.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.K.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.L.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.R.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.ki.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroMultisigKLRki {
            MoneroMultisigKLRki::new()
        }

        fn clear(&mut self) {
            self.K = ::std::option::Option::None;
            self.L = ::std::option::Option::None;
            self.R = ::std::option::Option::None;
            self.ki = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroMultisigKLRki {
            static instance: MoneroMultisigKLRki = MoneroMultisigKLRki {
                K: ::std::option::Option::None,
                L: ::std::option::Option::None,
                R: ::std::option::Option::None,
                ki: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroMultisigKLRki {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroMultisigKLRki").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroMultisigKLRki {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroMultisigKLRki {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Structure representing Monero transaction destination entry
///  @embed
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
pub struct MoneroTransactionDestinationEntry {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
    pub amount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
    pub addr: ::protobuf::MessageField<monero_transaction_destination_entry::MoneroAccountPublicAddress>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
    pub is_subaddress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry {
    fn default() -> &'a MoneroTransactionDestinationEntry {
        <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry {
    pub fn new() -> MoneroTransactionDestinationEntry {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;

    pub fn amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool is_subaddress = 3;

    pub fn is_subaddress(&self) -> bool {
        self.is_subaddress.unwrap_or(false)
    }

    pub fn clear_is_subaddress(&mut self) {
        self.is_subaddress = ::std::option::Option::None;
    }

    pub fn has_is_subaddress(&self) -> bool {
        self.is_subaddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subaddress(&mut self, v: bool) {
        self.is_subaddress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &MoneroTransactionDestinationEntry| { &m.amount },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_destination_entry::MoneroAccountPublicAddress>(
            "addr",
            |m: &MoneroTransactionDestinationEntry| { &m.addr },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_subaddress",
            |m: &MoneroTransactionDestinationEntry| { &m.is_subaddress },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_subaddress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionDestinationEntry>(
            "MoneroTransactionDestinationEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry {
    const NAME: &'static str = "MoneroTransactionDestinationEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.addr)?;
                },
                24 => {
                    self.is_subaddress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_subaddress {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.addr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.is_subaddress {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionDestinationEntry {
        MoneroTransactionDestinationEntry::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.addr.clear();
        self.is_subaddress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry {
        static instance: MoneroTransactionDestinationEntry = MoneroTransactionDestinationEntry {
            amount: ::std::option::Option::None,
            addr: ::protobuf::MessageField::none(),
            is_subaddress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionDestinationEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionDestinationEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionDestinationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionDestinationEntry`
pub mod monero_transaction_destination_entry {
    /// *
    ///  Structure representing Monero public address
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
    pub struct MoneroAccountPublicAddress {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
        pub spend_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
        pub view_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroAccountPublicAddress {
        fn default() -> &'a MoneroAccountPublicAddress {
            <MoneroAccountPublicAddress as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroAccountPublicAddress {
        pub fn new() -> MoneroAccountPublicAddress {
            ::std::default::Default::default()
        }

        // optional bytes spend_public_key = 1;

        pub fn spend_public_key(&self) -> &[u8] {
            match self.spend_public_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_spend_public_key(&mut self) {
            self.spend_public_key = ::std::option::Option::None;
        }

        pub fn has_spend_public_key(&self) -> bool {
            self.spend_public_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spend_public_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.spend_public_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_spend_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.spend_public_key.is_none() {
                self.spend_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.spend_public_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_spend_public_key(&mut self) -> ::std::vec::Vec<u8> {
            self.spend_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes view_public_key = 2;

        pub fn view_public_key(&self) -> &[u8] {
            match self.view_public_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_view_public_key(&mut self) {
            self.view_public_key = ::std::option::Option::None;
        }

        pub fn has_view_public_key(&self) -> bool {
            self.view_public_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.view_public_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.view_public_key.is_none() {
                self.view_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.view_public_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
            self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "spend_public_key",
                |m: &MoneroAccountPublicAddress| { &m.spend_public_key },
                |m: &mut MoneroAccountPublicAddress| { &mut m.spend_public_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "view_public_key",
                |m: &MoneroAccountPublicAddress| { &m.view_public_key },
                |m: &mut MoneroAccountPublicAddress| { &mut m.view_public_key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroAccountPublicAddress>(
                "MoneroTransactionDestinationEntry.MoneroAccountPublicAddress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroAccountPublicAddress {
        const NAME: &'static str = "MoneroAccountPublicAddress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.spend_public_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.view_public_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.spend_public_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.view_public_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.spend_public_key.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.view_public_key.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroAccountPublicAddress {
            MoneroAccountPublicAddress::new()
        }

        fn clear(&mut self) {
            self.spend_public_key = ::std::option::Option::None;
            self.view_public_key = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroAccountPublicAddress {
            static instance: MoneroAccountPublicAddress = MoneroAccountPublicAddress {
                spend_public_key: ::std::option::Option::None,
                view_public_key: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroAccountPublicAddress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionDestinationEntry.MoneroAccountPublicAddress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroAccountPublicAddress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroAccountPublicAddress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Range sig parameters / data.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionRsigData)
pub struct MoneroTransactionRsigData {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
    pub rsig_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
    pub offload_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
    pub grouping: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.step)
    pub step: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.operation)
    pub operation: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.seed)
    pub seed: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
    pub mask: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.amount)
    pub amount: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
    pub rsig: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
    pub rsig_parts: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.outputs)
    pub outputs: ::std::vec::Vec<MoneroTransactionDestinationEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionRsigData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionRsigData {
    fn default() -> &'a MoneroTransactionRsigData {
        <MoneroTransactionRsigData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionRsigData {
    pub fn new() -> MoneroTransactionRsigData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 rsig_type = 2;

    pub fn rsig_type(&self) -> u32 {
        self.rsig_type.unwrap_or(0)
    }

    pub fn clear_rsig_type(&mut self) {
        self.rsig_type = ::std::option::Option::None;
    }

    pub fn has_rsig_type(&self) -> bool {
        self.rsig_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_type(&mut self, v: u32) {
        self.rsig_type = ::std::option::Option::Some(v);
    }

    // optional uint32 offload_type = 3;

    pub fn offload_type(&self) -> u32 {
        self.offload_type.unwrap_or(0)
    }

    pub fn clear_offload_type(&mut self) {
        self.offload_type = ::std::option::Option::None;
    }

    pub fn has_offload_type(&self) -> bool {
        self.offload_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offload_type(&mut self, v: u32) {
        self.offload_type = ::std::option::Option::Some(v);
    }

    // optional uint32 step = 5;

    pub fn step(&self) -> u32 {
        self.step.unwrap_or(0)
    }

    pub fn clear_step(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        self.step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: u32) {
        self.step = ::std::option::Option::Some(v);
    }

    // optional uint64 operation = 6;

    pub fn operation(&self) -> u64 {
        self.operation.unwrap_or(0)
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: u64) {
        self.operation = ::std::option::Option::Some(v);
    }

    // optional bytes seed = 7;

    pub fn seed(&self) -> &[u8] {
        match self.seed.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.seed.is_none() {
            self.seed = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.seed.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed(&mut self) -> ::std::vec::Vec<u8> {
        self.seed.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mask = 8;

    pub fn mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes amount = 9;

    pub fn amount(&self) -> &[u8] {
        match self.amount.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.amount.is_none() {
            self.amount = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        self.amount.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rsig = 10;

    pub fn rsig(&self) -> &[u8] {
        match self.rsig.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rsig(&mut self) {
        self.rsig = ::std::option::Option::None;
    }

    pub fn has_rsig(&self) -> bool {
        self.rsig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig(&mut self, v: ::std::vec::Vec<u8>) {
        self.rsig = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rsig.is_none() {
            self.rsig = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rsig.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig(&mut self) -> ::std::vec::Vec<u8> {
        self.rsig.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MoneroTransactionRsigData| { &m.version },
            |m: &mut MoneroTransactionRsigData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rsig_type",
            |m: &MoneroTransactionRsigData| { &m.rsig_type },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offload_type",
            |m: &MoneroTransactionRsigData| { &m.offload_type },
            |m: &mut MoneroTransactionRsigData| { &mut m.offload_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grouping",
            |m: &MoneroTransactionRsigData| { &m.grouping },
            |m: &mut MoneroTransactionRsigData| { &mut m.grouping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "step",
            |m: &MoneroTransactionRsigData| { &m.step },
            |m: &mut MoneroTransactionRsigData| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &MoneroTransactionRsigData| { &m.operation },
            |m: &mut MoneroTransactionRsigData| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seed",
            |m: &MoneroTransactionRsigData| { &m.seed },
            |m: &mut MoneroTransactionRsigData| { &mut m.seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mask",
            |m: &MoneroTransactionRsigData| { &m.mask },
            |m: &mut MoneroTransactionRsigData| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &MoneroTransactionRsigData| { &m.amount },
            |m: &mut MoneroTransactionRsigData| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rsig",
            |m: &MoneroTransactionRsigData| { &m.rsig },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rsig_parts",
            |m: &MoneroTransactionRsigData| { &m.rsig_parts },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig_parts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MoneroTransactionRsigData| { &m.outputs },
            |m: &mut MoneroTransactionRsigData| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionRsigData>(
            "MoneroTransactionRsigData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionRsigData {
    const NAME: &'static str = "MoneroTransactionRsigData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rsig_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.offload_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.grouping)?;
                },
                32 => {
                    self.grouping.push(is.read_uint64()?);
                },
                40 => {
                    self.step = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.operation = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.seed = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.mask = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.amount = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.rsig = ::std::option::Option::Some(is.read_bytes()?);
                },
                90 => {
                    self.rsig_parts.push(is.read_bytes()?);
                },
                98 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rsig_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.offload_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.grouping {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.step {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.seed.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.amount.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.rsig.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        for value in &self.rsig_parts {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rsig_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.offload_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.grouping {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.step {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.operation {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.seed.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.mask.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.amount.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.rsig.as_ref() {
            os.write_bytes(10, v)?;
        }
        for v in &self.rsig_parts {
            os.write_bytes(11, &v)?;
        };
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionRsigData {
        MoneroTransactionRsigData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.rsig_type = ::std::option::Option::None;
        self.offload_type = ::std::option::Option::None;
        self.grouping.clear();
        self.step = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.seed = ::std::option::Option::None;
        self.mask = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rsig = ::std::option::Option::None;
        self.rsig_parts.clear();
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionRsigData {
        static instance: MoneroTransactionRsigData = MoneroTransactionRsigData {
            version: ::std::option::Option::None,
            rsig_type: ::std::option::Option::None,
            offload_type: ::std::option::Option::None,
            grouping: ::std::vec::Vec::new(),
            step: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            seed: ::std::option::Option::None,
            mask: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            rsig: ::std::option::Option::None,
            rsig_parts: ::std::vec::Vec::new(),
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionRsigData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionRsigData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionRsigData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionRsigData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Ask device for public address derived from seed and address_n
///  @start
///  @next MoneroAddress
///  @next Failure
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetAddress)
pub struct MoneroGetAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.show_display)
    pub show_display: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.network_type)
    pub network_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.minor)
    pub minor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetAddress {
    fn default() -> &'a MoneroGetAddress {
        <MoneroGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetAddress {
    pub fn new() -> MoneroGetAddress {
        ::std::default::Default::default()
    }

    // optional bool show_display = 2;

    pub fn show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }

    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }

    // optional uint32 network_type = 3;

    pub fn network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional uint32 account = 4;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint32 minor = 5;

    pub fn minor(&self) -> u32 {
        self.minor.unwrap_or(0)
    }

    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroGetAddress| { &m.address_n },
            |m: &mut MoneroGetAddress| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_display",
            |m: &MoneroGetAddress| { &m.show_display },
            |m: &mut MoneroGetAddress| { &mut m.show_display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroGetAddress| { &m.network_type },
            |m: &mut MoneroGetAddress| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MoneroGetAddress| { &m.account },
            |m: &mut MoneroGetAddress| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor",
            |m: &MoneroGetAddress| { &m.minor },
            |m: &mut MoneroGetAddress| { &mut m.minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetAddress>(
            "MoneroGetAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetAddress {
    const NAME: &'static str = "MoneroGetAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.show_display = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.network_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.show_display {
            my_size += 1 + 1;
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.minor {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetAddress {
        MoneroGetAddress::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetAddress {
        static instance: MoneroGetAddress = MoneroGetAddress {
            address_n: ::std::vec::Vec::new(),
            show_display: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            minor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Contains Monero watch-only credentials derived from device private seed
///  @end
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroAddress)
pub struct MoneroAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroAddress.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroAddress {
    fn default() -> &'a MoneroAddress {
        <MoneroAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroAddress {
    pub fn new() -> MoneroAddress {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MoneroAddress| { &m.address },
            |m: &mut MoneroAddress| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroAddress>(
            "MoneroAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroAddress {
    const NAME: &'static str = "MoneroAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroAddress {
        MoneroAddress::new()
    }

    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroAddress {
        static instance: MoneroAddress = MoneroAddress {
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Ask device for watch only credentials
///  @start
///  @next MoneroWatchKey
///  @next Failure
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetWatchKey)
pub struct MoneroGetWatchKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
    pub network_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetWatchKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetWatchKey {
    fn default() -> &'a MoneroGetWatchKey {
        <MoneroGetWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetWatchKey {
    pub fn new() -> MoneroGetWatchKey {
        ::std::default::Default::default()
    }

    // optional uint32 network_type = 2;

    pub fn network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroGetWatchKey| { &m.address_n },
            |m: &mut MoneroGetWatchKey| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroGetWatchKey| { &m.network_type },
            |m: &mut MoneroGetWatchKey| { &mut m.network_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetWatchKey>(
            "MoneroGetWatchKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetWatchKey {
    const NAME: &'static str = "MoneroGetWatchKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetWatchKey {
        MoneroGetWatchKey::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetWatchKey {
        static instance: MoneroGetWatchKey = MoneroGetWatchKey {
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetWatchKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetWatchKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetWatchKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Contains Monero watch-only credentials derived from device private seed
///  @end
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroWatchKey)
pub struct MoneroWatchKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
    pub watch_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroWatchKey.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroWatchKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroWatchKey {
    fn default() -> &'a MoneroWatchKey {
        <MoneroWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroWatchKey {
    pub fn new() -> MoneroWatchKey {
        ::std::default::Default::default()
    }

    // optional bytes watch_key = 1;

    pub fn watch_key(&self) -> &[u8] {
        match self.watch_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_watch_key(&mut self) {
        self.watch_key = ::std::option::Option::None;
    }

    pub fn has_watch_key(&self) -> bool {
        self.watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watch_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.watch_key.is_none() {
            self.watch_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.watch_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_watch_key(&mut self) -> ::std::vec::Vec<u8> {
        self.watch_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes address = 2;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watch_key",
            |m: &MoneroWatchKey| { &m.watch_key },
            |m: &mut MoneroWatchKey| { &mut m.watch_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MoneroWatchKey| { &m.address },
            |m: &mut MoneroWatchKey| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroWatchKey>(
            "MoneroWatchKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroWatchKey {
    const NAME: &'static str = "MoneroWatchKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.watch_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.watch_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.watch_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroWatchKey {
        MoneroWatchKey::new()
    }

    fn clear(&mut self) {
        self.watch_key = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroWatchKey {
        static instance: MoneroWatchKey = MoneroWatchKey {
            watch_key: ::std::option::Option::None,
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroWatchKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroWatchKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroWatchKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Initializes transaction signing.
///  @start
///  @next MoneroTransactionInitAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitRequest)
pub struct MoneroTransactionInitRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
    pub network_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
    pub tsx_data: ::protobuf::MessageField<monero_transaction_init_request::MoneroTransactionData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest {
    fn default() -> &'a MoneroTransactionInitRequest {
        <MoneroTransactionInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest {
    pub fn new() -> MoneroTransactionInitRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 network_type = 3;

    pub fn network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MoneroTransactionInitRequest| { &m.version },
            |m: &mut MoneroTransactionInitRequest| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroTransactionInitRequest| { &m.address_n },
            |m: &mut MoneroTransactionInitRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroTransactionInitRequest| { &m.network_type },
            |m: &mut MoneroTransactionInitRequest| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_init_request::MoneroTransactionData>(
            "tsx_data",
            |m: &MoneroTransactionInitRequest| { &m.tsx_data },
            |m: &mut MoneroTransactionInitRequest| { &mut m.tsx_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInitRequest>(
            "MoneroTransactionInitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest {
    const NAME: &'static str = "MoneroTransactionInitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                16 => {
                    self.address_n.push(is.read_uint32()?);
                },
                24 => {
                    self.network_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tsx_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tsx_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tsx_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInitRequest {
        MoneroTransactionInitRequest::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.tsx_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest {
        static instance: MoneroTransactionInitRequest = MoneroTransactionInitRequest {
            version: ::std::option::Option::None,
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            tsx_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionInitRequest`
pub mod monero_transaction_init_request {
    /// *
    ///  Structure representing Monero initial transaction information
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
    pub struct MoneroTransactionData {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
        pub version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
        pub payment_id: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
        pub unlock_time: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
        pub outputs: ::std::vec::Vec<super::MoneroTransactionDestinationEntry>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
        pub change_dts: ::protobuf::MessageField<super::MoneroTransactionDestinationEntry>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
        pub num_inputs: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
        pub mixin: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
        pub fee: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
        pub account: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
        pub minor_indices: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.is_multisig)
        pub is_multisig: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
        pub exp_tx_prefix_hash: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
        pub use_tx_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
        pub rsig_data: ::protobuf::MessageField<super::MoneroTransactionRsigData>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
        pub integrated_indices: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroTransactionData {
        fn default() -> &'a MoneroTransactionData {
            <MoneroTransactionData as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroTransactionData {
        pub fn new() -> MoneroTransactionData {
            ::std::default::Default::default()
        }

        // optional uint32 version = 1;

        pub fn version(&self) -> u32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional bytes payment_id = 2;

        pub fn payment_id(&self) -> &[u8] {
            match self.payment_id.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payment_id(&mut self) {
            self.payment_id = ::std::option::Option::None;
        }

        pub fn has_payment_id(&self) -> bool {
            self.payment_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
            self.payment_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.payment_id.is_none() {
                self.payment_id = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.payment_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
            self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 unlock_time = 3;

        pub fn unlock_time(&self) -> u64 {
            self.unlock_time.unwrap_or(0)
        }

        pub fn clear_unlock_time(&mut self) {
            self.unlock_time = ::std::option::Option::None;
        }

        pub fn has_unlock_time(&self) -> bool {
            self.unlock_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unlock_time(&mut self, v: u64) {
            self.unlock_time = ::std::option::Option::Some(v);
        }

        // optional uint32 num_inputs = 6;

        pub fn num_inputs(&self) -> u32 {
            self.num_inputs.unwrap_or(0)
        }

        pub fn clear_num_inputs(&mut self) {
            self.num_inputs = ::std::option::Option::None;
        }

        pub fn has_num_inputs(&self) -> bool {
            self.num_inputs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_inputs(&mut self, v: u32) {
            self.num_inputs = ::std::option::Option::Some(v);
        }

        // optional uint32 mixin = 7;

        pub fn mixin(&self) -> u32 {
            self.mixin.unwrap_or(0)
        }

        pub fn clear_mixin(&mut self) {
            self.mixin = ::std::option::Option::None;
        }

        pub fn has_mixin(&self) -> bool {
            self.mixin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mixin(&mut self, v: u32) {
            self.mixin = ::std::option::Option::Some(v);
        }

        // optional uint64 fee = 8;

        pub fn fee(&self) -> u64 {
            self.fee.unwrap_or(0)
        }

        pub fn clear_fee(&mut self) {
            self.fee = ::std::option::Option::None;
        }

        pub fn has_fee(&self) -> bool {
            self.fee.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fee(&mut self, v: u64) {
            self.fee = ::std::option::Option::Some(v);
        }

        // optional uint32 account = 9;

        pub fn account(&self) -> u32 {
            self.account.unwrap_or(0)
        }

        pub fn clear_account(&mut self) {
            self.account = ::std::option::Option::None;
        }

        pub fn has_account(&self) -> bool {
            self.account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account(&mut self, v: u32) {
            self.account = ::std::option::Option::Some(v);
        }

        // optional bool is_multisig = 11;

        pub fn is_multisig(&self) -> bool {
            self.is_multisig.unwrap_or(false)
        }

        pub fn clear_is_multisig(&mut self) {
            self.is_multisig = ::std::option::Option::None;
        }

        pub fn has_is_multisig(&self) -> bool {
            self.is_multisig.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_multisig(&mut self, v: bool) {
            self.is_multisig = ::std::option::Option::Some(v);
        }

        // optional bytes exp_tx_prefix_hash = 12;

        pub fn exp_tx_prefix_hash(&self) -> &[u8] {
            match self.exp_tx_prefix_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_exp_tx_prefix_hash(&mut self) {
            self.exp_tx_prefix_hash = ::std::option::Option::None;
        }

        pub fn has_exp_tx_prefix_hash(&self) -> bool {
            self.exp_tx_prefix_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_exp_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
            self.exp_tx_prefix_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_exp_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.exp_tx_prefix_hash.is_none() {
                self.exp_tx_prefix_hash = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.exp_tx_prefix_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_exp_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
            self.exp_tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(15);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &MoneroTransactionData| { &m.version },
                |m: &mut MoneroTransactionData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "payment_id",
                |m: &MoneroTransactionData| { &m.payment_id },
                |m: &mut MoneroTransactionData| { &mut m.payment_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unlock_time",
                |m: &MoneroTransactionData| { &m.unlock_time },
                |m: &mut MoneroTransactionData| { &mut m.unlock_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "outputs",
                |m: &MoneroTransactionData| { &m.outputs },
                |m: &mut MoneroTransactionData| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::MoneroTransactionDestinationEntry>(
                "change_dts",
                |m: &MoneroTransactionData| { &m.change_dts },
                |m: &mut MoneroTransactionData| { &mut m.change_dts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_inputs",
                |m: &MoneroTransactionData| { &m.num_inputs },
                |m: &mut MoneroTransactionData| { &mut m.num_inputs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mixin",
                |m: &MoneroTransactionData| { &m.mixin },
                |m: &mut MoneroTransactionData| { &mut m.mixin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fee",
                |m: &MoneroTransactionData| { &m.fee },
                |m: &mut MoneroTransactionData| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account",
                |m: &MoneroTransactionData| { &m.account },
                |m: &mut MoneroTransactionData| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "minor_indices",
                |m: &MoneroTransactionData| { &m.minor_indices },
                |m: &mut MoneroTransactionData| { &mut m.minor_indices },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_multisig",
                |m: &MoneroTransactionData| { &m.is_multisig },
                |m: &mut MoneroTransactionData| { &mut m.is_multisig },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "exp_tx_prefix_hash",
                |m: &MoneroTransactionData| { &m.exp_tx_prefix_hash },
                |m: &mut MoneroTransactionData| { &mut m.exp_tx_prefix_hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "use_tx_keys",
                |m: &MoneroTransactionData| { &m.use_tx_keys },
                |m: &mut MoneroTransactionData| { &mut m.use_tx_keys },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::MoneroTransactionRsigData>(
                "rsig_data",
                |m: &MoneroTransactionData| { &m.rsig_data },
                |m: &mut MoneroTransactionData| { &mut m.rsig_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "integrated_indices",
                |m: &MoneroTransactionData| { &m.integrated_indices },
                |m: &mut MoneroTransactionData| { &mut m.integrated_indices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionData>(
                "MoneroTransactionInitRequest.MoneroTransactionData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroTransactionData {
        const NAME: &'static str = "MoneroTransactionData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.payment_id = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    24 => {
                        self.unlock_time = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.outputs.push(is.read_message()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.change_dts)?;
                    },
                    48 => {
                        self.num_inputs = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.mixin = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.fee = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.account = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        is.read_repeated_packed_uint32_into(&mut self.minor_indices)?;
                    },
                    80 => {
                        self.minor_indices.push(is.read_uint32()?);
                    },
                    88 => {
                        self.is_multisig = ::std::option::Option::Some(is.read_bool()?);
                    },
                    98 => {
                        self.exp_tx_prefix_hash = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    106 => {
                        self.use_tx_keys.push(is.read_bytes()?);
                    },
                    114 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                    },
                    122 => {
                        is.read_repeated_packed_uint32_into(&mut self.integrated_indices)?;
                    },
                    120 => {
                        self.integrated_indices.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.payment_id.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.unlock_time {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            for value in &self.outputs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.change_dts.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.num_inputs {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.mixin {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.fee {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.account {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.minor_indices {
                my_size += ::protobuf::rt::uint32_size(10, *value);
            };
            if let Some(v) = self.is_multisig {
                my_size += 1 + 1;
            }
            if let Some(v) = self.exp_tx_prefix_hash.as_ref() {
                my_size += ::protobuf::rt::bytes_size(12, &v);
            }
            for value in &self.use_tx_keys {
                my_size += ::protobuf::rt::bytes_size(13, &value);
            };
            if let Some(v) = self.rsig_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.integrated_indices {
                my_size += ::protobuf::rt::uint32_size(15, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.version {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.payment_id.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.unlock_time {
                os.write_uint64(3, v)?;
            }
            for v in &self.outputs {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.change_dts.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.num_inputs {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.mixin {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.fee {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.account {
                os.write_uint32(9, v)?;
            }
            for v in &self.minor_indices {
                os.write_uint32(10, *v)?;
            };
            if let Some(v) = self.is_multisig {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.exp_tx_prefix_hash.as_ref() {
                os.write_bytes(12, v)?;
            }
            for v in &self.use_tx_keys {
                os.write_bytes(13, &v)?;
            };
            if let Some(v) = self.rsig_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            }
            for v in &self.integrated_indices {
                os.write_uint32(15, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroTransactionData {
            MoneroTransactionData::new()
        }

        fn clear(&mut self) {
            self.version = ::std::option::Option::None;
            self.payment_id = ::std::option::Option::None;
            self.unlock_time = ::std::option::Option::None;
            self.outputs.clear();
            self.change_dts.clear();
            self.num_inputs = ::std::option::Option::None;
            self.mixin = ::std::option::Option::None;
            self.fee = ::std::option::Option::None;
            self.account = ::std::option::Option::None;
            self.minor_indices.clear();
            self.is_multisig = ::std::option::Option::None;
            self.exp_tx_prefix_hash = ::std::option::Option::None;
            self.use_tx_keys.clear();
            self.rsig_data.clear();
            self.integrated_indices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroTransactionData {
            static instance: MoneroTransactionData = MoneroTransactionData {
                version: ::std::option::Option::None,
                payment_id: ::std::option::Option::None,
                unlock_time: ::std::option::Option::None,
                outputs: ::std::vec::Vec::new(),
                change_dts: ::protobuf::MessageField::none(),
                num_inputs: ::std::option::Option::None,
                mixin: ::std::option::Option::None,
                fee: ::std::option::Option::None,
                account: ::std::option::Option::None,
                minor_indices: ::std::vec::Vec::new(),
                is_multisig: ::std::option::Option::None,
                exp_tx_prefix_hash: ::std::option::Option::None,
                use_tx_keys: ::std::vec::Vec::new(),
                rsig_data: ::protobuf::MessageField::none(),
                integrated_indices: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroTransactionData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionInitRequest.MoneroTransactionData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroTransactionData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroTransactionData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Response: Response to transaction signing initialization.
///  @next MoneroTransactionSetInputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitAck)
pub struct MoneroTransactionInitAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.status)
    pub status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.in_memory)
    pub in_memory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
    pub hmacs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.many_inputs)
    pub many_inputs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.many_outputs)
    pub many_outputs: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitAck {
    fn default() -> &'a MoneroTransactionInitAck {
        <MoneroTransactionInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitAck {
    pub fn new() -> MoneroTransactionInitAck {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 2;

    pub fn status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional bool in_memory = 3;

    pub fn in_memory(&self) -> bool {
        self.in_memory.unwrap_or(false)
    }

    pub fn clear_in_memory(&mut self) {
        self.in_memory = ::std::option::Option::None;
    }

    pub fn has_in_memory(&self) -> bool {
        self.in_memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_memory(&mut self, v: bool) {
        self.in_memory = ::std::option::Option::Some(v);
    }

    // optional bool many_inputs = 5;

    pub fn many_inputs(&self) -> bool {
        self.many_inputs.unwrap_or(false)
    }

    pub fn clear_many_inputs(&mut self) {
        self.many_inputs = ::std::option::Option::None;
    }

    pub fn has_many_inputs(&self) -> bool {
        self.many_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_many_inputs(&mut self, v: bool) {
        self.many_inputs = ::std::option::Option::Some(v);
    }

    // optional bool many_outputs = 6;

    pub fn many_outputs(&self) -> bool {
        self.many_outputs.unwrap_or(false)
    }

    pub fn clear_many_outputs(&mut self) {
        self.many_outputs = ::std::option::Option::None;
    }

    pub fn has_many_outputs(&self) -> bool {
        self.many_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_many_outputs(&mut self, v: bool) {
        self.many_outputs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MoneroTransactionInitAck| { &m.version },
            |m: &mut MoneroTransactionInitAck| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &MoneroTransactionInitAck| { &m.status },
            |m: &mut MoneroTransactionInitAck| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_memory",
            |m: &MoneroTransactionInitAck| { &m.in_memory },
            |m: &mut MoneroTransactionInitAck| { &mut m.in_memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hmacs",
            |m: &MoneroTransactionInitAck| { &m.hmacs },
            |m: &mut MoneroTransactionInitAck| { &mut m.hmacs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "many_inputs",
            |m: &MoneroTransactionInitAck| { &m.many_inputs },
            |m: &mut MoneroTransactionInitAck| { &mut m.many_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "many_outputs",
            |m: &MoneroTransactionInitAck| { &m.many_outputs },
            |m: &mut MoneroTransactionInitAck| { &mut m.many_outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionInitAck| { &m.rsig_data },
            |m: &mut MoneroTransactionInitAck| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInitAck>(
            "MoneroTransactionInitAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInitAck {
    const NAME: &'static str = "MoneroTransactionInitAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.status = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_memory = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.hmacs.push(is.read_bytes()?);
                },
                40 => {
                    self.many_inputs = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.many_outputs = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_memory {
            my_size += 1 + 1;
        }
        for value in &self.hmacs {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.many_inputs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.many_outputs {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_memory {
            os.write_bool(3, v)?;
        }
        for v in &self.hmacs {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.many_inputs {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.many_outputs {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInitAck {
        MoneroTransactionInitAck::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.in_memory = ::std::option::Option::None;
        self.hmacs.clear();
        self.many_inputs = ::std::option::Option::None;
        self.many_outputs = ::std::option::Option::None;
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInitAck {
        static instance: MoneroTransactionInitAck = MoneroTransactionInitAck {
            version: ::std::option::Option::None,
            status: ::std::option::Option::None,
            in_memory: ::std::option::Option::None,
            hmacs: ::std::vec::Vec::new(),
            many_inputs: ::std::option::Option::None,
            many_outputs: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInitAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInitAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sends one UTXO to device
///  @next MoneroTransactionSetInputAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
pub struct MoneroTransactionSetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputRequest {
    fn default() -> &'a MoneroTransactionSetInputRequest {
        <MoneroTransactionSetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputRequest {
    pub fn new() -> MoneroTransactionSetInputRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MoneroTransactionSetInputRequest| { &m.version },
            |m: &mut MoneroTransactionSetInputRequest| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionSetInputRequest| { &m.src_entr },
            |m: &mut MoneroTransactionSetInputRequest| { &mut m.src_entr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetInputRequest>(
            "MoneroTransactionSetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputRequest {
    const NAME: &'static str = "MoneroTransactionSetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetInputRequest {
        MoneroTransactionSetInputRequest::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.src_entr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetInputRequest {
        static instance: MoneroTransactionSetInputRequest = MoneroTransactionSetInputRequest {
            version: ::std::option::Option::None,
            src_entr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to setting UTXO for signature. Contains sealed values needed for further protocol steps.
///  @next MoneroTransactionSetInputAck
///  @next MoneroTransactionInputsPermutationRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
pub struct MoneroTransactionSetInputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
    pub alpha_enc: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
    pub spend_enc: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputAck {
    fn default() -> &'a MoneroTransactionSetInputAck {
        <MoneroTransactionSetInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputAck {
    pub fn new() -> MoneroTransactionSetInputAck {
        ::std::default::Default::default()
    }

    // optional bytes vini = 1;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 2;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 3;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 4;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes alpha_enc = 5;

    pub fn alpha_enc(&self) -> &[u8] {
        match self.alpha_enc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_alpha_enc(&mut self) {
        self.alpha_enc = ::std::option::Option::None;
    }

    pub fn has_alpha_enc(&self) -> bool {
        self.alpha_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha_enc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.alpha_enc.is_none() {
            self.alpha_enc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.alpha_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_alpha_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.alpha_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_enc = 6;

    pub fn spend_enc(&self) -> &[u8] {
        match self.spend_enc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spend_enc(&mut self) {
        self.spend_enc = ::std::option::Option::None;
    }

    pub fn has_spend_enc(&self) -> bool {
        self.spend_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_enc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_enc.is_none() {
            self.spend_enc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spend_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionSetInputAck| { &m.vini },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionSetInputAck| { &m.vini_hmac },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionSetInputAck| { &m.pseudo_out },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alpha_enc",
            |m: &MoneroTransactionSetInputAck| { &m.alpha_enc },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.alpha_enc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spend_enc",
            |m: &MoneroTransactionSetInputAck| { &m.spend_enc },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.spend_enc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetInputAck>(
            "MoneroTransactionSetInputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputAck {
    const NAME: &'static str = "MoneroTransactionSetInputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.alpha_enc = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.spend_enc = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.alpha_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.spend_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.alpha_enc.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.spend_enc.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetInputAck {
        MoneroTransactionSetInputAck::new()
    }

    fn clear(&mut self) {
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.alpha_enc = ::std::option::Option::None;
        self.spend_enc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetInputAck {
        static instance: MoneroTransactionSetInputAck = MoneroTransactionSetInputAck {
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            alpha_enc: ::std::option::Option::None,
            spend_enc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetInputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetInputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Permutation on key images.
///  @next MoneroTransactionInputsPermutationAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest)
pub struct MoneroTransactionInputsPermutationRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
    pub perm: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationRequest {
    fn default() -> &'a MoneroTransactionInputsPermutationRequest {
        <MoneroTransactionInputsPermutationRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationRequest {
    pub fn new() -> MoneroTransactionInputsPermutationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "perm",
            |m: &MoneroTransactionInputsPermutationRequest| { &m.perm },
            |m: &mut MoneroTransactionInputsPermutationRequest| { &mut m.perm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputsPermutationRequest>(
            "MoneroTransactionInputsPermutationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationRequest {
    const NAME: &'static str = "MoneroTransactionInputsPermutationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.perm)?;
                },
                8 => {
                    self.perm.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.perm {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.perm {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputsPermutationRequest {
        MoneroTransactionInputsPermutationRequest::new()
    }

    fn clear(&mut self) {
        self.perm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationRequest {
        static instance: MoneroTransactionInputsPermutationRequest = MoneroTransactionInputsPermutationRequest {
            perm: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputsPermutationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputsPermutationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputsPermutationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to setting permutation on key images
///  @next MoneroTransactionInputViniRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputsPermutationAck)
pub struct MoneroTransactionInputsPermutationAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputsPermutationAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationAck {
    fn default() -> &'a MoneroTransactionInputsPermutationAck {
        <MoneroTransactionInputsPermutationAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationAck {
    pub fn new() -> MoneroTransactionInputsPermutationAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputsPermutationAck>(
            "MoneroTransactionInputsPermutationAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationAck {
    const NAME: &'static str = "MoneroTransactionInputsPermutationAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputsPermutationAck {
        MoneroTransactionInputsPermutationAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationAck {
        static instance: MoneroTransactionInputsPermutationAck = MoneroTransactionInputsPermutationAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputsPermutationAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputsPermutationAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputsPermutationAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sends one UTXO to device together with sealed values.
///  @next MoneroTransactionInputViniAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
pub struct MoneroTransactionInputViniRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniRequest {
    fn default() -> &'a MoneroTransactionInputViniRequest {
        <MoneroTransactionInputViniRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniRequest {
    pub fn new() -> MoneroTransactionInputViniRequest {
        ::std::default::Default::default()
    }

    // optional bytes vini = 2;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionInputViniRequest| { &m.src_entr },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.src_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionInputViniRequest| { &m.vini },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionInputViniRequest| { &m.vini_hmac },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out_hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputViniRequest>(
            "MoneroTransactionInputViniRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniRequest {
    const NAME: &'static str = "MoneroTransactionInputViniRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                18 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputViniRequest {
        MoneroTransactionInputViniRequest::new()
    }

    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputViniRequest {
        static instance: MoneroTransactionInputViniRequest = MoneroTransactionInputViniRequest {
            src_entr: ::protobuf::MessageField::none(),
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputViniRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputViniRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputViniRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to setting UTXO to the device
///  @next MoneroTransactionInputViniRequest
///  @next MoneroTransactionAllInputsSetRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
pub struct MoneroTransactionInputViniAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputViniAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniAck {
    fn default() -> &'a MoneroTransactionInputViniAck {
        <MoneroTransactionInputViniAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniAck {
    pub fn new() -> MoneroTransactionInputViniAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputViniAck>(
            "MoneroTransactionInputViniAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniAck {
    const NAME: &'static str = "MoneroTransactionInputViniAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputViniAck {
        MoneroTransactionInputViniAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputViniAck {
        static instance: MoneroTransactionInputViniAck = MoneroTransactionInputViniAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputViniAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputViniAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputViniAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sent after all inputs have been sent. Useful for rangeisg offloading.
///  @next MoneroTransactionAllInputsSetAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
pub struct MoneroTransactionAllInputsSetRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetRequest {
    fn default() -> &'a MoneroTransactionAllInputsSetRequest {
        <MoneroTransactionAllInputsSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetRequest {
    pub fn new() -> MoneroTransactionAllInputsSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllInputsSetRequest| { &m.rsig_data },
            |m: &mut MoneroTransactionAllInputsSetRequest| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllInputsSetRequest>(
            "MoneroTransactionAllInputsSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetRequest {
    const NAME: &'static str = "MoneroTransactionAllInputsSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllInputsSetRequest {
        MoneroTransactionAllInputsSetRequest::new()
    }

    fn clear(&mut self) {
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetRequest {
        static instance: MoneroTransactionAllInputsSetRequest = MoneroTransactionAllInputsSetRequest {
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllInputsSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllInputsSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllInputsSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to after all inputs have been set.
///  @next MoneroTransactionSetOutputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
pub struct MoneroTransactionAllInputsSetAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetAck {
    fn default() -> &'a MoneroTransactionAllInputsSetAck {
        <MoneroTransactionAllInputsSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetAck {
    pub fn new() -> MoneroTransactionAllInputsSetAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllInputsSetAck| { &m.rsig_data },
            |m: &mut MoneroTransactionAllInputsSetAck| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllInputsSetAck>(
            "MoneroTransactionAllInputsSetAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetAck {
    const NAME: &'static str = "MoneroTransactionAllInputsSetAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllInputsSetAck {
        MoneroTransactionAllInputsSetAck::new()
    }

    fn clear(&mut self) {
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetAck {
        static instance: MoneroTransactionAllInputsSetAck = MoneroTransactionAllInputsSetAck {
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllInputsSetAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllInputsSetAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllInputsSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sends one transaction destination to device (HMACed)
///  @next MoneroTransactionSetOutputAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
pub struct MoneroTransactionSetOutputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
    pub dst_entr: ::protobuf::MessageField<MoneroTransactionDestinationEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
    pub dst_entr_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputRequest {
    fn default() -> &'a MoneroTransactionSetOutputRequest {
        <MoneroTransactionSetOutputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputRequest {
    pub fn new() -> MoneroTransactionSetOutputRequest {
        ::std::default::Default::default()
    }

    // optional bytes dst_entr_hmac = 2;

    pub fn dst_entr_hmac(&self) -> &[u8] {
        match self.dst_entr_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dst_entr_hmac(&mut self) {
        self.dst_entr_hmac = ::std::option::Option::None;
    }

    pub fn has_dst_entr_hmac(&self) -> bool {
        self.dst_entr_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.dst_entr_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dst_entr_hmac.is_none() {
            self.dst_entr_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dst_entr_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.dst_entr_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionDestinationEntry>(
            "dst_entr",
            |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_entr_hmac",
            |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr_hmac },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionSetOutputRequest| { &m.rsig_data },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetOutputRequest>(
            "MoneroTransactionSetOutputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputRequest {
    const NAME: &'static str = "MoneroTransactionSetOutputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dst_entr)?;
                },
                18 => {
                    self.dst_entr_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dst_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dst_entr_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dst_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dst_entr_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetOutputRequest {
        MoneroTransactionSetOutputRequest::new()
    }

    fn clear(&mut self) {
        self.dst_entr.clear();
        self.dst_entr_hmac = ::std::option::Option::None;
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputRequest {
        static instance: MoneroTransactionSetOutputRequest = MoneroTransactionSetOutputRequest {
            dst_entr: ::protobuf::MessageField::none(),
            dst_entr_hmac: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetOutputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetOutputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetOutputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to setting transaction destination. Contains sealed values needed for further protocol steps.
///  @next MoneroTransactionSetOutputRequest
///  @next MoneroTransactionAllOutSetRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
pub struct MoneroTransactionSetOutputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
    pub tx_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
    pub vouti_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
    pub out_pk: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
    pub ecdh_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputAck {
    fn default() -> &'a MoneroTransactionSetOutputAck {
        <MoneroTransactionSetOutputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputAck {
    pub fn new() -> MoneroTransactionSetOutputAck {
        ::std::default::Default::default()
    }

    // optional bytes tx_out = 1;

    pub fn tx_out(&self) -> &[u8] {
        match self.tx_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_out(&mut self) {
        self.tx_out = ::std::option::Option::None;
    }

    pub fn has_tx_out(&self) -> bool {
        self.tx_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_out.is_none() {
            self.tx_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_out(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vouti_hmac = 2;

    pub fn vouti_hmac(&self) -> &[u8] {
        match self.vouti_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vouti_hmac(&mut self) {
        self.vouti_hmac = ::std::option::Option::None;
    }

    pub fn has_vouti_hmac(&self) -> bool {
        self.vouti_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vouti_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vouti_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vouti_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vouti_hmac.is_none() {
            self.vouti_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vouti_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vouti_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vouti_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes out_pk = 4;

    pub fn out_pk(&self) -> &[u8] {
        match self.out_pk.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_out_pk(&mut self) {
        self.out_pk = ::std::option::Option::None;
    }

    pub fn has_out_pk(&self) -> bool {
        self.out_pk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_pk(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_pk = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_pk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_pk.is_none() {
            self.out_pk = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.out_pk.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_pk(&mut self) -> ::std::vec::Vec<u8> {
        self.out_pk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ecdh_info = 5;

    pub fn ecdh_info(&self) -> &[u8] {
        match self.ecdh_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ecdh_info(&mut self) {
        self.ecdh_info = ::std::option::Option::None;
    }

    pub fn has_ecdh_info(&self) -> bool {
        self.ecdh_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdh_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.ecdh_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdh_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ecdh_info.is_none() {
            self.ecdh_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ecdh_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdh_info(&mut self) -> ::std::vec::Vec<u8> {
        self.ecdh_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_out",
            |m: &MoneroTransactionSetOutputAck| { &m.tx_out },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.tx_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vouti_hmac",
            |m: &MoneroTransactionSetOutputAck| { &m.vouti_hmac },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.vouti_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionSetOutputAck| { &m.rsig_data },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.rsig_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_pk",
            |m: &MoneroTransactionSetOutputAck| { &m.out_pk },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.out_pk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecdh_info",
            |m: &MoneroTransactionSetOutputAck| { &m.ecdh_info },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.ecdh_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetOutputAck>(
            "MoneroTransactionSetOutputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputAck {
    const NAME: &'static str = "MoneroTransactionSetOutputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.vouti_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                34 => {
                    self.out_pk = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.ecdh_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tx_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.vouti_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.out_pk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecdh_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tx_out.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.vouti_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.out_pk.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecdh_info.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetOutputAck {
        MoneroTransactionSetOutputAck::new()
    }

    fn clear(&mut self) {
        self.tx_out = ::std::option::Option::None;
        self.vouti_hmac = ::std::option::Option::None;
        self.rsig_data.clear();
        self.out_pk = ::std::option::Option::None;
        self.ecdh_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputAck {
        static instance: MoneroTransactionSetOutputAck = MoneroTransactionSetOutputAck {
            tx_out: ::std::option::Option::None,
            vouti_hmac: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            out_pk: ::std::option::Option::None,
            ecdh_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetOutputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetOutputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetOutputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sent after all outputs are sent.
///  @next MoneroTransactionAllOutSetAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
pub struct MoneroTransactionAllOutSetRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetRequest {
    fn default() -> &'a MoneroTransactionAllOutSetRequest {
        <MoneroTransactionAllOutSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetRequest {
    pub fn new() -> MoneroTransactionAllOutSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllOutSetRequest| { &m.rsig_data },
            |m: &mut MoneroTransactionAllOutSetRequest| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllOutSetRequest>(
            "MoneroTransactionAllOutSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetRequest {
    const NAME: &'static str = "MoneroTransactionAllOutSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllOutSetRequest {
        MoneroTransactionAllOutSetRequest::new()
    }

    fn clear(&mut self) {
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetRequest {
        static instance: MoneroTransactionAllOutSetRequest = MoneroTransactionAllOutSetRequest {
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllOutSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllOutSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: After all outputs are sent the initial RCT signature fields are sent.
///  @next MoneroTransactionMlsagDoneRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
pub struct MoneroTransactionAllOutSetAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
    pub extra: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
    pub tx_prefix_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
    pub rv: ::protobuf::MessageField<monero_transaction_all_out_set_ack::MoneroRingCtSig>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck {
    fn default() -> &'a MoneroTransactionAllOutSetAck {
        <MoneroTransactionAllOutSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck {
    pub fn new() -> MoneroTransactionAllOutSetAck {
        ::std::default::Default::default()
    }

    // optional bytes extra = 1;

    pub fn extra(&self) -> &[u8] {
        match self.extra.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_extra(&mut self) {
        self.extra = ::std::option::Option::None;
    }

    pub fn has_extra(&self) -> bool {
        self.extra.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra.is_none() {
            self.extra = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.extra.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra(&mut self) -> ::std::vec::Vec<u8> {
        self.extra.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_prefix_hash = 2;

    pub fn tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash = ::std::option::Option::None;
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extra",
            |m: &MoneroTransactionAllOutSetAck| { &m.extra },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.extra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_prefix_hash",
            |m: &MoneroTransactionAllOutSetAck| { &m.tx_prefix_hash },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.tx_prefix_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllOutSetAck| { &m.rsig_data },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rsig_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_all_out_set_ack::MoneroRingCtSig>(
            "rv",
            |m: &MoneroTransactionAllOutSetAck| { &m.rv },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllOutSetAck>(
            "MoneroTransactionAllOutSetAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck {
    const NAME: &'static str = "MoneroTransactionAllOutSetAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.extra = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.tx_prefix_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rv)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.extra.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.extra.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.rv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllOutSetAck {
        MoneroTransactionAllOutSetAck::new()
    }

    fn clear(&mut self) {
        self.extra = ::std::option::Option::None;
        self.tx_prefix_hash = ::std::option::Option::None;
        self.rsig_data.clear();
        self.rv.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck {
        static instance: MoneroTransactionAllOutSetAck = MoneroTransactionAllOutSetAck {
            extra: ::std::option::Option::None,
            tx_prefix_hash: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            rv: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllOutSetAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllOutSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionAllOutSetAck`
pub mod monero_transaction_all_out_set_ack {
    ///
    ///  Structure represents initial fields of the Monero RCT signature
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
    pub struct MoneroRingCtSig {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
        pub txn_fee: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
        pub message: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
        pub rv_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroRingCtSig {
        fn default() -> &'a MoneroRingCtSig {
            <MoneroRingCtSig as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroRingCtSig {
        pub fn new() -> MoneroRingCtSig {
            ::std::default::Default::default()
        }

        // optional uint64 txn_fee = 1;

        pub fn txn_fee(&self) -> u64 {
            self.txn_fee.unwrap_or(0)
        }

        pub fn clear_txn_fee(&mut self) {
            self.txn_fee = ::std::option::Option::None;
        }

        pub fn has_txn_fee(&self) -> bool {
            self.txn_fee.is_some()
        }

        // Param is passed by value, moved
        pub fn set_txn_fee(&mut self, v: u64) {
            self.txn_fee = ::std::option::Option::Some(v);
        }

        // optional bytes message = 2;

        pub fn message(&self) -> &[u8] {
            match self.message.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
            self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 rv_type = 3;

        pub fn rv_type(&self) -> u32 {
            self.rv_type.unwrap_or(0)
        }

        pub fn clear_rv_type(&mut self) {
            self.rv_type = ::std::option::Option::None;
        }

        pub fn has_rv_type(&self) -> bool {
            self.rv_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rv_type(&mut self, v: u32) {
            self.rv_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "txn_fee",
                |m: &MoneroRingCtSig| { &m.txn_fee },
                |m: &mut MoneroRingCtSig| { &mut m.txn_fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &MoneroRingCtSig| { &m.message },
                |m: &mut MoneroRingCtSig| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rv_type",
                |m: &MoneroRingCtSig| { &m.rv_type },
                |m: &mut MoneroRingCtSig| { &mut m.rv_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroRingCtSig>(
                "MoneroTransactionAllOutSetAck.MoneroRingCtSig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroRingCtSig {
        const NAME: &'static str = "MoneroRingCtSig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.txn_fee = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.message = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    24 => {
                        self.rv_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.txn_fee {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.rv_type {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.txn_fee {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.rv_type {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroRingCtSig {
            MoneroRingCtSig::new()
        }

        fn clear(&mut self) {
            self.txn_fee = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.rv_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroRingCtSig {
            static instance: MoneroRingCtSig = MoneroRingCtSig {
                txn_fee: ::std::option::Option::None,
                message: ::std::option::Option::None,
                rv_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroRingCtSig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetAck.MoneroRingCtSig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroRingCtSig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroRingCtSig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Request: Sub request of MoneroTransactionSign.
///  @next MoneroTransactionMlsagDoneAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionMlsagDoneRequest)
pub struct MoneroTransactionMlsagDoneRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionMlsagDoneRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionMlsagDoneRequest {
    fn default() -> &'a MoneroTransactionMlsagDoneRequest {
        <MoneroTransactionMlsagDoneRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionMlsagDoneRequest {
    pub fn new() -> MoneroTransactionMlsagDoneRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionMlsagDoneRequest>(
            "MoneroTransactionMlsagDoneRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionMlsagDoneRequest {
    const NAME: &'static str = "MoneroTransactionMlsagDoneRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionMlsagDoneRequest {
        MoneroTransactionMlsagDoneRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionMlsagDoneRequest {
        static instance: MoneroTransactionMlsagDoneRequest = MoneroTransactionMlsagDoneRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionMlsagDoneRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionMlsagDoneRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionMlsagDoneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionMlsagDoneRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Contains full message hash needed for the signature
///  @next MoneroTransactionSignInputRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck)
pub struct MoneroTransactionMlsagDoneAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
    pub full_message_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionMlsagDoneAck {
    fn default() -> &'a MoneroTransactionMlsagDoneAck {
        <MoneroTransactionMlsagDoneAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionMlsagDoneAck {
    pub fn new() -> MoneroTransactionMlsagDoneAck {
        ::std::default::Default::default()
    }

    // optional bytes full_message_hash = 1;

    pub fn full_message_hash(&self) -> &[u8] {
        match self.full_message_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_full_message_hash(&mut self) {
        self.full_message_hash = ::std::option::Option::None;
    }

    pub fn has_full_message_hash(&self) -> bool {
        self.full_message_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_message_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_message_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_message_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_message_hash.is_none() {
            self.full_message_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.full_message_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_message_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.full_message_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_message_hash",
            |m: &MoneroTransactionMlsagDoneAck| { &m.full_message_hash },
            |m: &mut MoneroTransactionMlsagDoneAck| { &mut m.full_message_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionMlsagDoneAck>(
            "MoneroTransactionMlsagDoneAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionMlsagDoneAck {
    const NAME: &'static str = "MoneroTransactionMlsagDoneAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.full_message_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.full_message_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.full_message_hash.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionMlsagDoneAck {
        MoneroTransactionMlsagDoneAck::new()
    }

    fn clear(&mut self) {
        self.full_message_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionMlsagDoneAck {
        static instance: MoneroTransactionMlsagDoneAck = MoneroTransactionMlsagDoneAck {
            full_message_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionMlsagDoneAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionMlsagDoneAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionMlsagDoneAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionMlsagDoneAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Sends UTXO for the signing.
///  @next MoneroTransactionSignInputAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
pub struct MoneroTransactionSignInputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
    pub alpha_enc: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
    pub spend_enc: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputRequest {
    fn default() -> &'a MoneroTransactionSignInputRequest {
        <MoneroTransactionSignInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputRequest {
    pub fn new() -> MoneroTransactionSignInputRequest {
        ::std::default::Default::default()
    }

    // optional bytes vini = 2;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes alpha_enc = 6;

    pub fn alpha_enc(&self) -> &[u8] {
        match self.alpha_enc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_alpha_enc(&mut self) {
        self.alpha_enc = ::std::option::Option::None;
    }

    pub fn has_alpha_enc(&self) -> bool {
        self.alpha_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha_enc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.alpha_enc.is_none() {
            self.alpha_enc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.alpha_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_alpha_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.alpha_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_enc = 7;

    pub fn spend_enc(&self) -> &[u8] {
        match self.spend_enc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spend_enc(&mut self) {
        self.spend_enc = ::std::option::Option::None;
    }

    pub fn has_spend_enc(&self) -> bool {
        self.spend_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_enc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_enc.is_none() {
            self.spend_enc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spend_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionSignInputRequest| { &m.src_entr },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.src_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionSignInputRequest| { &m.vini },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionSignInputRequest| { &m.vini_hmac },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alpha_enc",
            |m: &MoneroTransactionSignInputRequest| { &m.alpha_enc },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.alpha_enc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spend_enc",
            |m: &MoneroTransactionSignInputRequest| { &m.spend_enc },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.spend_enc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSignInputRequest>(
            "MoneroTransactionSignInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputRequest {
    const NAME: &'static str = "MoneroTransactionSignInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                18 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.alpha_enc = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.spend_enc = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.alpha_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.spend_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.alpha_enc.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.spend_enc.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSignInputRequest {
        MoneroTransactionSignInputRequest::new()
    }

    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.alpha_enc = ::std::option::Option::None;
        self.spend_enc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSignInputRequest {
        static instance: MoneroTransactionSignInputRequest = MoneroTransactionSignInputRequest {
            src_entr: ::protobuf::MessageField::none(),
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            alpha_enc: ::std::option::Option::None,
            spend_enc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSignInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSignInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSignInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Contains full MG signature of the UTXO + multisig data if applicable.
///  @next MoneroTransactionSignInputRequest
///  @next MoneroTransactionFinalRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
pub struct MoneroTransactionSignInputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
    pub cout: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputAck {
    fn default() -> &'a MoneroTransactionSignInputAck {
        <MoneroTransactionSignInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputAck {
    pub fn new() -> MoneroTransactionSignInputAck {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes cout = 2;

    pub fn cout(&self) -> &[u8] {
        match self.cout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cout(&mut self) {
        self.cout = ::std::option::Option::None;
    }

    pub fn has_cout(&self) -> bool {
        self.cout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout.is_none() {
            self.cout = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.cout.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout(&mut self) -> ::std::vec::Vec<u8> {
        self.cout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &MoneroTransactionSignInputAck| { &m.signature },
            |m: &mut MoneroTransactionSignInputAck| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cout",
            |m: &MoneroTransactionSignInputAck| { &m.cout },
            |m: &mut MoneroTransactionSignInputAck| { &mut m.cout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSignInputAck>(
            "MoneroTransactionSignInputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputAck {
    const NAME: &'static str = "MoneroTransactionSignInputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.cout = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.cout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.cout.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSignInputAck {
        MoneroTransactionSignInputAck::new()
    }

    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.cout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSignInputAck {
        static instance: MoneroTransactionSignInputAck = MoneroTransactionSignInputAck {
            signature: ::std::option::Option::None,
            cout: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSignInputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSignInputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSignInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroTransactionSign. Final message of the procol after all UTXOs are signed
///  @next MoneroTransactionFinalAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
pub struct MoneroTransactionFinalRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionFinalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalRequest {
    fn default() -> &'a MoneroTransactionFinalRequest {
        <MoneroTransactionFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalRequest {
    pub fn new() -> MoneroTransactionFinalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionFinalRequest>(
            "MoneroTransactionFinalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionFinalRequest {
    const NAME: &'static str = "MoneroTransactionFinalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionFinalRequest {
        MoneroTransactionFinalRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionFinalRequest {
        static instance: MoneroTransactionFinalRequest = MoneroTransactionFinalRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionFinalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionFinalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Contains transaction metadata and encryption keys needed for further transaction operations (e.g. multisig, send proof).
///  @end
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionFinalAck)
pub struct MoneroTransactionFinalAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
    pub cout_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
    pub salt: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
    pub rand_mult: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
    pub tx_enc_keys: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionFinalAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalAck {
    fn default() -> &'a MoneroTransactionFinalAck {
        <MoneroTransactionFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalAck {
    pub fn new() -> MoneroTransactionFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes cout_key = 1;

    pub fn cout_key(&self) -> &[u8] {
        match self.cout_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cout_key(&mut self) {
        self.cout_key = ::std::option::Option::None;
    }

    pub fn has_cout_key(&self) -> bool {
        self.cout_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout_key.is_none() {
            self.cout_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.cout_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout_key(&mut self) -> ::std::vec::Vec<u8> {
        self.cout_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt = 2;

    pub fn salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt(&mut self) {
        self.salt = ::std::option::Option::None;
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rand_mult = 3;

    pub fn rand_mult(&self) -> &[u8] {
        match self.rand_mult.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rand_mult(&mut self) {
        self.rand_mult = ::std::option::Option::None;
    }

    pub fn has_rand_mult(&self) -> bool {
        self.rand_mult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rand_mult(&mut self, v: ::std::vec::Vec<u8>) {
        self.rand_mult = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rand_mult(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rand_mult.is_none() {
            self.rand_mult = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rand_mult.as_mut().unwrap()
    }

    // Take field
    pub fn take_rand_mult(&mut self) -> ::std::vec::Vec<u8> {
        self.rand_mult.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_enc_keys = 4;

    pub fn tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys = ::std::option::Option::None;
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cout_key",
            |m: &MoneroTransactionFinalAck| { &m.cout_key },
            |m: &mut MoneroTransactionFinalAck| { &mut m.cout_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt",
            |m: &MoneroTransactionFinalAck| { &m.salt },
            |m: &mut MoneroTransactionFinalAck| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rand_mult",
            |m: &MoneroTransactionFinalAck| { &m.rand_mult },
            |m: &mut MoneroTransactionFinalAck| { &mut m.rand_mult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_enc_keys",
            |m: &MoneroTransactionFinalAck| { &m.tx_enc_keys },
            |m: &mut MoneroTransactionFinalAck| { &mut m.tx_enc_keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionFinalAck>(
            "MoneroTransactionFinalAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionFinalAck {
    const NAME: &'static str = "MoneroTransactionFinalAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cout_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.rand_mult = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.tx_enc_keys = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cout_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rand_mult.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cout_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.salt.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rand_mult.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionFinalAck {
        MoneroTransactionFinalAck::new()
    }

    fn clear(&mut self) {
        self.cout_key = ::std::option::Option::None;
        self.salt = ::std::option::Option::None;
        self.rand_mult = ::std::option::Option::None;
        self.tx_enc_keys = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionFinalAck {
        static instance: MoneroTransactionFinalAck = MoneroTransactionFinalAck {
            cout_key: ::std::option::Option::None,
            salt: ::std::option::Option::None,
            rand_mult: ::std::option::Option::None,
            tx_enc_keys: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionFinalAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionFinalAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroKeyImageSync. Initializing key image sync.
///  @start
///  @next MoneroKeyImageExportInitAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
pub struct MoneroKeyImageExportInitRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
    pub num: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
    pub hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
    pub network_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
    pub subs: ::std::vec::Vec<monero_key_image_export_init_request::MoneroSubAddressIndicesList>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest {
    fn default() -> &'a MoneroKeyImageExportInitRequest {
        <MoneroKeyImageExportInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest {
    pub fn new() -> MoneroKeyImageExportInitRequest {
        ::std::default::Default::default()
    }

    // optional uint64 num = 1;

    pub fn num(&self) -> u64 {
        self.num.unwrap_or(0)
    }

    pub fn clear_num(&mut self) {
        self.num = ::std::option::Option::None;
    }

    pub fn has_num(&self) -> bool {
        self.num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: u64) {
        self.num = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;

    pub fn hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 4;

    pub fn network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num",
            |m: &MoneroKeyImageExportInitRequest| { &m.num },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &MoneroKeyImageExportInitRequest| { &m.hash },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroKeyImageExportInitRequest| { &m.address_n },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroKeyImageExportInitRequest| { &m.network_type },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subs",
            |m: &MoneroKeyImageExportInitRequest| { &m.subs },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.subs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageExportInitRequest>(
            "MoneroKeyImageExportInitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest {
    const NAME: &'static str = "MoneroKeyImageExportInitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                24 => {
                    self.address_n.push(is.read_uint32()?);
                },
                32 => {
                    self.network_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.subs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.subs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(4, v)?;
        }
        for v in &self.subs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageExportInitRequest {
        MoneroKeyImageExportInitRequest::new()
    }

    fn clear(&mut self) {
        self.num = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.subs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest {
        static instance: MoneroKeyImageExportInitRequest = MoneroKeyImageExportInitRequest {
            num: ::std::option::Option::None,
            hash: ::std::option::Option::None,
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            subs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageExportInitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageExportInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageExportInitRequest`
pub mod monero_key_image_export_init_request {
    /// *
    ///  Structure representing Monero list of sub-addresses
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
    pub struct MoneroSubAddressIndicesList {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
        pub account: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
        pub minor_indices: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroSubAddressIndicesList {
        fn default() -> &'a MoneroSubAddressIndicesList {
            <MoneroSubAddressIndicesList as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroSubAddressIndicesList {
        pub fn new() -> MoneroSubAddressIndicesList {
            ::std::default::Default::default()
        }

        // optional uint32 account = 1;

        pub fn account(&self) -> u32 {
            self.account.unwrap_or(0)
        }

        pub fn clear_account(&mut self) {
            self.account = ::std::option::Option::None;
        }

        pub fn has_account(&self) -> bool {
            self.account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account(&mut self, v: u32) {
            self.account = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account",
                |m: &MoneroSubAddressIndicesList| { &m.account },
                |m: &mut MoneroSubAddressIndicesList| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "minor_indices",
                |m: &MoneroSubAddressIndicesList| { &m.minor_indices },
                |m: &mut MoneroSubAddressIndicesList| { &mut m.minor_indices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroSubAddressIndicesList>(
                "MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroSubAddressIndicesList {
        const NAME: &'static str = "MoneroSubAddressIndicesList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.minor_indices)?;
                    },
                    16 => {
                        self.minor_indices.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.minor_indices {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account {
                os.write_uint32(1, v)?;
            }
            for v in &self.minor_indices {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroSubAddressIndicesList {
            MoneroSubAddressIndicesList::new()
        }

        fn clear(&mut self) {
            self.account = ::std::option::Option::None;
            self.minor_indices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroSubAddressIndicesList {
            static instance: MoneroSubAddressIndicesList = MoneroSubAddressIndicesList {
                account: ::std::option::Option::None,
                minor_indices: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroSubAddressIndicesList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroSubAddressIndicesList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroSubAddressIndicesList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Response: Response to key image sync initialization.
///  @next MoneroKeyImageSyncStepRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
pub struct MoneroKeyImageExportInitAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitAck {
    fn default() -> &'a MoneroKeyImageExportInitAck {
        <MoneroKeyImageExportInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitAck {
    pub fn new() -> MoneroKeyImageExportInitAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageExportInitAck>(
            "MoneroKeyImageExportInitAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitAck {
    const NAME: &'static str = "MoneroKeyImageExportInitAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageExportInitAck {
        MoneroKeyImageExportInitAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitAck {
        static instance: MoneroKeyImageExportInitAck = MoneroKeyImageExportInitAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageExportInitAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageExportInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Sub request of MoneroKeyImageSync. Contains batch of the UTXO to export key image for.
///  @next MoneroKeyImageSyncStepAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
pub struct MoneroKeyImageSyncStepRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
    pub tdis: ::std::vec::Vec<monero_key_image_sync_step_request::MoneroTransferDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest {
    fn default() -> &'a MoneroKeyImageSyncStepRequest {
        <MoneroKeyImageSyncStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest {
    pub fn new() -> MoneroKeyImageSyncStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tdis",
            |m: &MoneroKeyImageSyncStepRequest| { &m.tdis },
            |m: &mut MoneroKeyImageSyncStepRequest| { &mut m.tdis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncStepRequest>(
            "MoneroKeyImageSyncStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest {
    const NAME: &'static str = "MoneroKeyImageSyncStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tdis.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tdis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tdis {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncStepRequest {
        MoneroKeyImageSyncStepRequest::new()
    }

    fn clear(&mut self) {
        self.tdis.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest {
        static instance: MoneroKeyImageSyncStepRequest = MoneroKeyImageSyncStepRequest {
            tdis: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageSyncStepRequest`
pub mod monero_key_image_sync_step_request {
    /// *
    ///  Structure representing Monero UTXO for key image sync
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
    pub struct MoneroTransferDetails {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
        pub out_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
        pub tx_pub_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
        pub additional_tx_pub_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
        pub internal_output_index: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroTransferDetails {
        fn default() -> &'a MoneroTransferDetails {
            <MoneroTransferDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroTransferDetails {
        pub fn new() -> MoneroTransferDetails {
            ::std::default::Default::default()
        }

        // optional bytes out_key = 1;

        pub fn out_key(&self) -> &[u8] {
            match self.out_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_out_key(&mut self) {
            self.out_key = ::std::option::Option::None;
        }

        pub fn has_out_key(&self) -> bool {
            self.out_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.out_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.out_key.is_none() {
                self.out_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.out_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
            self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes tx_pub_key = 2;

        pub fn tx_pub_key(&self) -> &[u8] {
            match self.tx_pub_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_tx_pub_key(&mut self) {
            self.tx_pub_key = ::std::option::Option::None;
        }

        pub fn has_tx_pub_key(&self) -> bool {
            self.tx_pub_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tx_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.tx_pub_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tx_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.tx_pub_key.is_none() {
                self.tx_pub_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.tx_pub_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_tx_pub_key(&mut self) -> ::std::vec::Vec<u8> {
            self.tx_pub_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 internal_output_index = 4;

        pub fn internal_output_index(&self) -> u64 {
            self.internal_output_index.unwrap_or(0)
        }

        pub fn clear_internal_output_index(&mut self) {
            self.internal_output_index = ::std::option::Option::None;
        }

        pub fn has_internal_output_index(&self) -> bool {
            self.internal_output_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_output_index(&mut self, v: u64) {
            self.internal_output_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "out_key",
                |m: &MoneroTransferDetails| { &m.out_key },
                |m: &mut MoneroTransferDetails| { &mut m.out_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tx_pub_key",
                |m: &MoneroTransferDetails| { &m.tx_pub_key },
                |m: &mut MoneroTransferDetails| { &mut m.tx_pub_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "additional_tx_pub_keys",
                |m: &MoneroTransferDetails| { &m.additional_tx_pub_keys },
                |m: &mut MoneroTransferDetails| { &mut m.additional_tx_pub_keys },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_output_index",
                |m: &MoneroTransferDetails| { &m.internal_output_index },
                |m: &mut MoneroTransferDetails| { &mut m.internal_output_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransferDetails>(
                "MoneroKeyImageSyncStepRequest.MoneroTransferDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroTransferDetails {
        const NAME: &'static str = "MoneroTransferDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.out_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.tx_pub_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.additional_tx_pub_keys.push(is.read_bytes()?);
                    },
                    32 => {
                        self.internal_output_index = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.out_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.tx_pub_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            for value in &self.additional_tx_pub_keys {
                my_size += ::protobuf::rt::bytes_size(3, &value);
            };
            if let Some(v) = self.internal_output_index {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.out_key.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.tx_pub_key.as_ref() {
                os.write_bytes(2, v)?;
            }
            for v in &self.additional_tx_pub_keys {
                os.write_bytes(3, &v)?;
            };
            if let Some(v) = self.internal_output_index {
                os.write_uint64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroTransferDetails {
            MoneroTransferDetails::new()
        }

        fn clear(&mut self) {
            self.out_key = ::std::option::Option::None;
            self.tx_pub_key = ::std::option::Option::None;
            self.additional_tx_pub_keys.clear();
            self.internal_output_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroTransferDetails {
            static instance: MoneroTransferDetails = MoneroTransferDetails {
                out_key: ::std::option::Option::None,
                tx_pub_key: ::std::option::Option::None,
                additional_tx_pub_keys: ::std::vec::Vec::new(),
                internal_output_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroTransferDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepRequest.MoneroTransferDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroTransferDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroTransferDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Response: Response to key image sync step. Contains encrypted exported key image.
///  @next MoneroKeyImageSyncStepRequest
///  @next MoneroKeyImageSyncFinalRequest
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
pub struct MoneroKeyImageSyncStepAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
    pub kis: ::std::vec::Vec<monero_key_image_sync_step_ack::MoneroExportedKeyImage>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck {
    fn default() -> &'a MoneroKeyImageSyncStepAck {
        <MoneroKeyImageSyncStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck {
    pub fn new() -> MoneroKeyImageSyncStepAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kis",
            |m: &MoneroKeyImageSyncStepAck| { &m.kis },
            |m: &mut MoneroKeyImageSyncStepAck| { &mut m.kis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncStepAck>(
            "MoneroKeyImageSyncStepAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck {
    const NAME: &'static str = "MoneroKeyImageSyncStepAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kis.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.kis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.kis {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncStepAck {
        MoneroKeyImageSyncStepAck::new()
    }

    fn clear(&mut self) {
        self.kis.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck {
        static instance: MoneroKeyImageSyncStepAck = MoneroKeyImageSyncStepAck {
            kis: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncStepAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageSyncStepAck`
pub mod monero_key_image_sync_step_ack {
    /// *
    ///  Structure representing Monero encrypted exported key image
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
    pub struct MoneroExportedKeyImage {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
        pub iv: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
        pub tag: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
        pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroExportedKeyImage {
        fn default() -> &'a MoneroExportedKeyImage {
            <MoneroExportedKeyImage as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroExportedKeyImage {
        pub fn new() -> MoneroExportedKeyImage {
            ::std::default::Default::default()
        }

        // optional bytes iv = 1;

        pub fn iv(&self) -> &[u8] {
            match self.iv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_iv(&mut self) {
            self.iv = ::std::option::Option::None;
        }

        pub fn has_iv(&self) -> bool {
            self.iv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
            self.iv = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.iv.is_none() {
                self.iv = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.iv.as_mut().unwrap()
        }

        // Take field
        pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
            self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes tag = 2;

        pub fn tag(&self) -> &[u8] {
            match self.tag.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_tag(&mut self) {
            self.tag = ::std::option::Option::None;
        }

        pub fn has_tag(&self) -> bool {
            self.tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag(&mut self, v: ::std::vec::Vec<u8>) {
            self.tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.tag.is_none() {
                self.tag = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag(&mut self) -> ::std::vec::Vec<u8> {
            self.tag.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes blob = 3;

        pub fn blob(&self) -> &[u8] {
            match self.blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_blob(&mut self) {
            self.blob = ::std::option::Option::None;
        }

        pub fn has_blob(&self) -> bool {
            self.blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.blob.is_none() {
                self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "iv",
                |m: &MoneroExportedKeyImage| { &m.iv },
                |m: &mut MoneroExportedKeyImage| { &mut m.iv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag",
                |m: &MoneroExportedKeyImage| { &m.tag },
                |m: &mut MoneroExportedKeyImage| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "blob",
                |m: &MoneroExportedKeyImage| { &m.blob },
                |m: &mut MoneroExportedKeyImage| { &mut m.blob },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroExportedKeyImage>(
                "MoneroKeyImageSyncStepAck.MoneroExportedKeyImage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroExportedKeyImage {
        const NAME: &'static str = "MoneroExportedKeyImage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.iv = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.tag = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.blob = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.iv.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.tag.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.iv.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.tag.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.blob.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroExportedKeyImage {
            MoneroExportedKeyImage::new()
        }

        fn clear(&mut self) {
            self.iv = ::std::option::Option::None;
            self.tag = ::std::option::Option::None;
            self.blob = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroExportedKeyImage {
            static instance: MoneroExportedKeyImage = MoneroExportedKeyImage {
                iv: ::std::option::Option::None,
                tag: ::std::option::Option::None,
                blob: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroExportedKeyImage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepAck.MoneroExportedKeyImage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroExportedKeyImage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroExportedKeyImage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// *
///  Request: Sub request of MoneroKeyImageSync. Final message of the sync protocol.
///  @next MoneroKeyImageSyncFinalAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
pub struct MoneroKeyImageSyncFinalRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalRequest {
    fn default() -> &'a MoneroKeyImageSyncFinalRequest {
        <MoneroKeyImageSyncFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalRequest {
    pub fn new() -> MoneroKeyImageSyncFinalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncFinalRequest>(
            "MoneroKeyImageSyncFinalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalRequest {
    const NAME: &'static str = "MoneroKeyImageSyncFinalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncFinalRequest {
        MoneroKeyImageSyncFinalRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalRequest {
        static instance: MoneroKeyImageSyncFinalRequest = MoneroKeyImageSyncFinalRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncFinalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncFinalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to key image sync step. Contains encryption keys for exported key images.
///  @end
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
pub struct MoneroKeyImageSyncFinalAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
    pub enc_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalAck {
    fn default() -> &'a MoneroKeyImageSyncFinalAck {
        <MoneroKeyImageSyncFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalAck {
    pub fn new() -> MoneroKeyImageSyncFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes enc_key = 1;

    pub fn enc_key(&self) -> &[u8] {
        match self.enc_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_enc_key(&mut self) {
        self.enc_key = ::std::option::Option::None;
    }

    pub fn has_enc_key(&self) -> bool {
        self.enc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enc_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.enc_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enc_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enc_key.is_none() {
            self.enc_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.enc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_enc_key(&mut self) -> ::std::vec::Vec<u8> {
        self.enc_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enc_key",
            |m: &MoneroKeyImageSyncFinalAck| { &m.enc_key },
            |m: &mut MoneroKeyImageSyncFinalAck| { &mut m.enc_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncFinalAck>(
            "MoneroKeyImageSyncFinalAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalAck {
    const NAME: &'static str = "MoneroKeyImageSyncFinalAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.enc_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enc_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enc_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncFinalAck {
        MoneroKeyImageSyncFinalAck::new()
    }

    fn clear(&mut self) {
        self.enc_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalAck {
        static instance: MoneroKeyImageSyncFinalAck = MoneroKeyImageSyncFinalAck {
            enc_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncFinalAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncFinalAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Request: Universal Monero protocol implementation diagnosis request.
///  @start
///  @next DebugMoneroDiagAck
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.DebugMoneroDiagRequest)
pub struct DebugMoneroDiagRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
    pub ins: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
    pub p1: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
    pub p2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
    pub pd: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
    pub data1: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
    pub data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.DebugMoneroDiagRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagRequest {
    fn default() -> &'a DebugMoneroDiagRequest {
        <DebugMoneroDiagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagRequest {
    pub fn new() -> DebugMoneroDiagRequest {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;

    pub fn ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }

    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;

    pub fn p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }

    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;

    pub fn p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }

    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // optional bytes data1 = 5;

    pub fn data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data1(&mut self) {
        self.data1 = ::std::option::Option::None;
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;

    pub fn data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data2(&mut self) {
        self.data2 = ::std::option::Option::None;
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ins",
            |m: &DebugMoneroDiagRequest| { &m.ins },
            |m: &mut DebugMoneroDiagRequest| { &mut m.ins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p1",
            |m: &DebugMoneroDiagRequest| { &m.p1 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.p1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p2",
            |m: &DebugMoneroDiagRequest| { &m.p2 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.p2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pd",
            |m: &DebugMoneroDiagRequest| { &m.pd },
            |m: &mut DebugMoneroDiagRequest| { &mut m.pd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data1",
            |m: &DebugMoneroDiagRequest| { &m.data1 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data2",
            |m: &DebugMoneroDiagRequest| { &m.data2 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.data2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugMoneroDiagRequest>(
            "DebugMoneroDiagRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugMoneroDiagRequest {
    const NAME: &'static str = "DebugMoneroDiagRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ins = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.p1 = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.p2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.pd)?;
                },
                32 => {
                    self.pd.push(is.read_uint64()?);
                },
                42 => {
                    self.data1 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.data1.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugMoneroDiagRequest {
        DebugMoneroDiagRequest::new()
    }

    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1 = ::std::option::Option::None;
        self.data2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugMoneroDiagRequest {
        static instance: DebugMoneroDiagRequest = DebugMoneroDiagRequest {
            ins: ::std::option::Option::None,
            p1: ::std::option::Option::None,
            p2: ::std::option::Option::None,
            pd: ::std::vec::Vec::new(),
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugMoneroDiagRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugMoneroDiagRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugMoneroDiagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Response: Response to Monero diagnosis protocol.
///  @end
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.DebugMoneroDiagAck)
pub struct DebugMoneroDiagAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
    pub ins: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
    pub p1: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
    pub p2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
    pub pd: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
    pub data1: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
    pub data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.DebugMoneroDiagAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagAck {
    fn default() -> &'a DebugMoneroDiagAck {
        <DebugMoneroDiagAck as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagAck {
    pub fn new() -> DebugMoneroDiagAck {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;

    pub fn ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }

    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;

    pub fn p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }

    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;

    pub fn p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }

    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // optional bytes data1 = 5;

    pub fn data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data1(&mut self) {
        self.data1 = ::std::option::Option::None;
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;

    pub fn data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data2(&mut self) {
        self.data2 = ::std::option::Option::None;
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ins",
            |m: &DebugMoneroDiagAck| { &m.ins },
            |m: &mut DebugMoneroDiagAck| { &mut m.ins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p1",
            |m: &DebugMoneroDiagAck| { &m.p1 },
            |m: &mut DebugMoneroDiagAck| { &mut m.p1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p2",
            |m: &DebugMoneroDiagAck| { &m.p2 },
            |m: &mut DebugMoneroDiagAck| { &mut m.p2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pd",
            |m: &DebugMoneroDiagAck| { &m.pd },
            |m: &mut DebugMoneroDiagAck| { &mut m.pd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data1",
            |m: &DebugMoneroDiagAck| { &m.data1 },
            |m: &mut DebugMoneroDiagAck| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data2",
            |m: &DebugMoneroDiagAck| { &m.data2 },
            |m: &mut DebugMoneroDiagAck| { &mut m.data2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugMoneroDiagAck>(
            "DebugMoneroDiagAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugMoneroDiagAck {
    const NAME: &'static str = "DebugMoneroDiagAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ins = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.p1 = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.p2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.pd)?;
                },
                32 => {
                    self.pd.push(is.read_uint64()?);
                },
                42 => {
                    self.data1 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.data1.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugMoneroDiagAck {
        DebugMoneroDiagAck::new()
    }

    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1 = ::std::option::Option::None;
        self.data2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugMoneroDiagAck {
        static instance: DebugMoneroDiagAck = DebugMoneroDiagAck {
            ins: ::std::option::Option::None,
            p1: ::std::option::Option::None,
            p2: ::std::option::Option::None,
            pd: ::std::vec::Vec::new(),
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugMoneroDiagAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugMoneroDiagAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugMoneroDiagAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-monero.proto\x12\x19hw.trezor.messages.monero\"\x8c\x06\n\
    \x1cMoneroTransactionSourceEntry\x12c\n\x07outputs\x18\x01\x20\x03(\x0b2\
    I.hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEnt\
    ryR\x07outputs\x12\x1f\n\x0breal_output\x18\x02\x20\x01(\x04R\nrealOutpu\
    t\x12%\n\x0freal_out_tx_key\x18\x03\x20\x01(\x0cR\x0crealOutTxKey\x12<\n\
    \x1breal_out_additional_tx_keys\x18\x04\x20\x03(\x0cR\x17realOutAddition\
    alTxKeys\x124\n\x17real_output_in_tx_index\x18\x05\x20\x01(\x04R\x13real\
    OutputInTxIndex\x12\x16\n\x06amount\x18\x06\x20\x01(\x04R\x06amount\x12\
    \x10\n\x03rct\x18\x07\x20\x01(\x08R\x03rct\x12\x12\n\x04mask\x18\x08\x20\
    \x01(\x0cR\x04mask\x12r\n\x0emultisig_kLRki\x18\t\x20\x01(\x0b2K.hw.trez\
    or.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRkiR\rmu\
    ltisigKLRki\x1a\xc7\x01\n\x11MoneroOutputEntry\x12\x10\n\x03idx\x18\x01\
    \x20\x01(\x04R\x03idx\x12h\n\x03key\x18\x02\x20\x01(\x0b2V.hw.trezor.mes\
    sages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey\
    R\x03key\x1a6\n\x0cMoneroRctKey\x12\x12\n\x04dest\x18\x01\x20\x01(\x0cR\
    \x04dest\x12\x12\n\x04mask\x18\x02\x20\x01(\x0cR\x04mask\x1aO\n\x13Moner\
    oMultisigKLRki\x12\x0c\n\x01K\x18\x01\x20\x01(\x0cR\x01K\x12\x0c\n\x01L\
    \x18\x02\x20\x01(\x0cR\x01L\x12\x0c\n\x01R\x18\x03\x20\x01(\x0cR\x01R\
    \x12\x0e\n\x02ki\x18\x04\x20\x01(\x0cR\x02ki\"\xbd\x02\n!MoneroTransacti\
    onDestinationEntry\x12\x16\n\x06amount\x18\x01\x20\x01(\x04R\x06amount\
    \x12k\n\x04addr\x18\x02\x20\x01(\x0b2W.hw.trezor.messages.monero.MoneroT\
    ransactionDestinationEntry.MoneroAccountPublicAddressR\x04addr\x12#\n\ri\
    s_subaddress\x18\x03\x20\x01(\x08R\x0cisSubaddress\x1an\n\x1aMoneroAccou\
    ntPublicAddress\x12(\n\x10spend_public_key\x18\x01\x20\x01(\x0cR\x0espen\
    dPublicKey\x12&\n\x0fview_public_key\x18\x02\x20\x01(\x0cR\rviewPublicKe\
    y\"\x8e\x03\n\x19MoneroTransactionRsigData\x12\x18\n\x07version\x18\x01\
    \x20\x01(\rR\x07version\x12\x1b\n\trsig_type\x18\x02\x20\x01(\rR\x08rsig\
    Type\x12!\n\x0coffload_type\x18\x03\x20\x01(\rR\x0boffloadType\x12\x1a\n\
    \x08grouping\x18\x04\x20\x03(\x04R\x08grouping\x12\x12\n\x04step\x18\x05\
    \x20\x01(\rR\x04step\x12\x1c\n\toperation\x18\x06\x20\x01(\x04R\toperati\
    on\x12\x12\n\x04seed\x18\x07\x20\x01(\x0cR\x04seed\x12\x12\n\x04mask\x18\
    \x08\x20\x01(\x0cR\x04mask\x12\x16\n\x06amount\x18\t\x20\x01(\x0cR\x06am\
    ount\x12\x12\n\x04rsig\x18\n\x20\x01(\x0cR\x04rsig\x12\x1d\n\nrsig_parts\
    \x18\x0b\x20\x03(\x0cR\trsigParts\x12V\n\x07outputs\x18\x0c\x20\x03(\x0b\
    2<.hw.trezor.messages.monero.MoneroTransactionDestinationEntryR\x07outpu\
    ts\"\xa5\x01\n\x10MoneroGetAddress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\
    \rR\x08addressN\x12!\n\x0cshow_display\x18\x02\x20\x01(\x08R\x0bshowDisp\
    lay\x12!\n\x0cnetwork_type\x18\x03\x20\x01(\rR\x0bnetworkType\x12\x18\n\
    \x07account\x18\x04\x20\x01(\rR\x07account\x12\x14\n\x05minor\x18\x05\
    \x20\x01(\rR\x05minor\")\n\rMoneroAddress\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x0cR\x07address\"S\n\x11MoneroGetWatchKey\x12\x1b\n\taddress_n\
    \x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x02\x20\x01(\
    \rR\x0bnetworkType\"G\n\x0eMoneroWatchKey\x12\x1b\n\twatch_key\x18\x01\
    \x20\x01(\x0cR\x08watchKey\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\
    \x07address\"\x81\x07\n\x1cMoneroTransactionInitRequest\x12\x18\n\x07ver\
    sion\x18\x01\x20\x01(\rR\x07version\x12\x1b\n\taddress_n\x18\x02\x20\x03\
    (\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x03\x20\x01(\rR\x0bnetworkTy\
    pe\x12h\n\x08tsx_data\x18\x04\x20\x01(\x0b2M.hw.trezor.messages.monero.M\
    oneroTransactionInitRequest.MoneroTransactionDataR\x07tsxData\x1a\x9c\
    \x05\n\x15MoneroTransactionData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\x12\x1d\n\npayment_id\x18\x02\x20\x01(\x0cR\tpaymentId\x12\
    \x1f\n\x0bunlock_time\x18\x03\x20\x01(\x04R\nunlockTime\x12V\n\x07output\
    s\x18\x04\x20\x03(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDest\
    inationEntryR\x07outputs\x12[\n\nchange_dts\x18\x05\x20\x01(\x0b2<.hw.tr\
    ezor.messages.monero.MoneroTransactionDestinationEntryR\tchangeDts\x12\
    \x1d\n\nnum_inputs\x18\x06\x20\x01(\rR\tnumInputs\x12\x14\n\x05mixin\x18\
    \x07\x20\x01(\rR\x05mixin\x12\x10\n\x03fee\x18\x08\x20\x01(\x04R\x03fee\
    \x12\x18\n\x07account\x18\t\x20\x01(\rR\x07account\x12#\n\rminor_indices\
    \x18\n\x20\x03(\rR\x0cminorIndices\x12\x1f\n\x0bis_multisig\x18\x0b\x20\
    \x01(\x08R\nisMultisig\x12+\n\x12exp_tx_prefix_hash\x18\x0c\x20\x01(\x0c\
    R\x0fexpTxPrefixHash\x12\x1e\n\x0buse_tx_keys\x18\r\x20\x03(\x0cR\tuseTx\
    Keys\x12Q\n\trsig_data\x18\x0e\x20\x01(\x0b24.hw.trezor.messages.monero.\
    MoneroTransactionRsigDataR\x08rsigData\x12-\n\x12integrated_indices\x18\
    \x0f\x20\x03(\rR\x11integratedIndices\"\x96\x02\n\x18MoneroTransactionIn\
    itAck\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x16\n\x06s\
    tatus\x18\x02\x20\x01(\rR\x06status\x12\x1b\n\tin_memory\x18\x03\x20\x01\
    (\x08R\x08inMemory\x12\x14\n\x05hmacs\x18\x04\x20\x03(\x0cR\x05hmacs\x12\
    \x1f\n\x0bmany_inputs\x18\x05\x20\x01(\x08R\nmanyInputs\x12!\n\x0cmany_o\
    utputs\x18\x06\x20\x01(\x08R\x0bmanyOutputs\x12Q\n\trsig_data\x18\x07\
    \x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08\
    rsigData\"\x90\x01\n\x20MoneroTransactionSetInputRequest\x12\x18\n\x07ve\
    rsion\x18\x01\x20\x01(\rR\x07version\x12R\n\x08src_entr\x18\x02\x20\x01(\
    \x0b27.hw.trezor.messages.monero.MoneroTransactionSourceEntryR\x07srcEnt\
    r\"\xd0\x01\n\x1cMoneroTransactionSetInputAck\x12\x12\n\x04vini\x18\x01\
    \x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hmac\x18\x02\x20\x01(\x0cR\x08vin\
    iHmac\x12\x1d\n\npseudo_out\x18\x03\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fp\
    seudo_out_hmac\x18\x04\x20\x01(\x0cR\rpseudoOutHmac\x12\x1b\n\talpha_enc\
    \x18\x05\x20\x01(\x0cR\x08alphaEnc\x12\x1b\n\tspend_enc\x18\x06\x20\x01(\
    \x0cR\x08spendEnc\"?\n)MoneroTransactionInputsPermutationRequest\x12\x12\
    \n\x04perm\x18\x01\x20\x03(\rR\x04perm\"'\n%MoneroTransactionInputsPermu\
    tationAck\"\xef\x01\n!MoneroTransactionInputViniRequest\x12R\n\x08src_en\
    tr\x18\x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTransactionSou\
    rceEntryR\x07srcEntr\x12\x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\x12\
    \x1b\n\tvini_hmac\x18\x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_ou\
    t\x18\x04\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\x20\
    \x01(\x0cR\rpseudoOutHmac\"\x1f\n\x1dMoneroTransactionInputViniAck\"y\n$\
    MoneroTransactionAllInputsSetRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\
    \x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08rsigData\
    \"u\n\x20MoneroTransactionAllInputsSetAck\x12Q\n\trsig_data\x18\x01\x20\
    \x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08rsig\
    Data\"\xf3\x01\n!MoneroTransactionSetOutputRequest\x12W\n\x08dst_entr\
    \x18\x01\x20\x01(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDesti\
    nationEntryR\x07dstEntr\x12\"\n\rdst_entr_hmac\x18\x02\x20\x01(\x0cR\x0b\
    dstEntrHmac\x12Q\n\trsig_data\x18\x03\x20\x01(\x0b24.hw.trezor.messages.\
    monero.MoneroTransactionRsigDataR\x08rsigData\"\xdc\x01\n\x1dMoneroTrans\
    actionSetOutputAck\x12\x15\n\x06tx_out\x18\x01\x20\x01(\x0cR\x05txOut\
    \x12\x1d\n\nvouti_hmac\x18\x02\x20\x01(\x0cR\tvoutiHmac\x12Q\n\trsig_dat\
    a\x18\x03\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsig\
    DataR\x08rsigData\x12\x15\n\x06out_pk\x18\x04\x20\x01(\x0cR\x05outPk\x12\
    \x1b\n\tecdh_info\x18\x05\x20\x01(\x0cR\x08ecdhInfo\"v\n!MoneroTransacti\
    onAllOutSetRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\x0b24.hw.trezor.me\
    ssages.monero.MoneroTransactionRsigDataR\x08rsigData\"\xe7\x02\n\x1dMone\
    roTransactionAllOutSetAck\x12\x14\n\x05extra\x18\x01\x20\x01(\x0cR\x05ex\
    tra\x12$\n\x0etx_prefix_hash\x18\x02\x20\x01(\x0cR\x0ctxPrefixHash\x12Q\
    \n\trsig_data\x18\x03\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTra\
    nsactionRsigDataR\x08rsigData\x12X\n\x02rv\x18\x04\x20\x01(\x0b2H.hw.tre\
    zor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSigR\x02rv\
    \x1a]\n\x0fMoneroRingCtSig\x12\x17\n\x07txn_fee\x18\x01\x20\x01(\x04R\
    \x06txnFee\x12\x18\n\x07message\x18\x02\x20\x01(\x0cR\x07message\x12\x17\
    \n\x07rv_type\x18\x03\x20\x01(\rR\x06rvType\"#\n!MoneroTransactionMlsagD\
    oneRequest\"K\n\x1dMoneroTransactionMlsagDoneAck\x12*\n\x11full_message_\
    hash\x18\x01\x20\x01(\x0cR\x0ffullMessageHash\"\xa9\x02\n!MoneroTransact\
    ionSignInputRequest\x12R\n\x08src_entr\x18\x01\x20\x01(\x0b27.hw.trezor.\
    messages.monero.MoneroTransactionSourceEntryR\x07srcEntr\x12\x12\n\x04vi\
    ni\x18\x02\x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hmac\x18\x03\x20\x01(\
    \x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\x04\x20\x01(\x0cR\tpseudoOut\
    \x12&\n\x0fpseudo_out_hmac\x18\x05\x20\x01(\x0cR\rpseudoOutHmac\x12\x1b\
    \n\talpha_enc\x18\x06\x20\x01(\x0cR\x08alphaEnc\x12\x1b\n\tspend_enc\x18\
    \x07\x20\x01(\x0cR\x08spendEnc\"Q\n\x1dMoneroTransactionSignInputAck\x12\
    \x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignature\x12\x12\n\x04cout\x18\
    \x02\x20\x01(\x0cR\x04cout\"\x1f\n\x1dMoneroTransactionFinalRequest\"\
    \x87\x01\n\x19MoneroTransactionFinalAck\x12\x19\n\x08cout_key\x18\x01\
    \x20\x01(\x0cR\x07coutKey\x12\x12\n\x04salt\x18\x02\x20\x01(\x0cR\x04sal\
    t\x12\x1b\n\trand_mult\x18\x03\x20\x01(\x0cR\x08randMult\x12\x1e\n\x0btx\
    _enc_keys\x18\x04\x20\x01(\x0cR\ttxEncKeys\"\xd1\x02\n\x1fMoneroKeyImage\
    ExportInitRequest\x12\x10\n\x03num\x18\x01\x20\x01(\x04R\x03num\x12\x12\
    \n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1b\n\taddress_n\x18\x03\
    \x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x04\x20\x01(\rR\x0bn\
    etworkType\x12j\n\x04subs\x18\x05\x20\x03(\x0b2V.hw.trezor.messages.mone\
    ro.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesListR\x04subs\
    \x1a\\\n\x1bMoneroSubAddressIndicesList\x12\x18\n\x07account\x18\x01\x20\
    \x01(\rR\x07account\x12#\n\rminor_indices\x18\x02\x20\x03(\rR\x0cminorIn\
    dices\"\x1d\n\x1bMoneroKeyImageExportInitAck\"\xbd\x02\n\x1dMoneroKeyIma\
    geSyncStepRequest\x12b\n\x04tdis\x18\x01\x20\x03(\x0b2N.hw.trezor.messag\
    es.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetailsR\x04tdis\
    \x1a\xb7\x01\n\x15MoneroTransferDetails\x12\x17\n\x07out_key\x18\x01\x20\
    \x01(\x0cR\x06outKey\x12\x1c\n\ntx_pub_key\x18\x02\x20\x01(\x0cR\x08txPu\
    bKey\x123\n\x16additional_tx_pub_keys\x18\x03\x20\x03(\x0cR\x13additiona\
    lTxPubKeys\x122\n\x15internal_output_index\x18\x04\x20\x01(\x04R\x13inte\
    rnalOutputIndex\"\xca\x01\n\x19MoneroKeyImageSyncStepAck\x12]\n\x03kis\
    \x18\x01\x20\x03(\x0b2K.hw.trezor.messages.monero.MoneroKeyImageSyncStep\
    Ack.MoneroExportedKeyImageR\x03kis\x1aN\n\x16MoneroExportedKeyImage\x12\
    \x0e\n\x02iv\x18\x01\x20\x01(\x0cR\x02iv\x12\x10\n\x03tag\x18\x02\x20\
    \x01(\x0cR\x03tag\x12\x12\n\x04blob\x18\x03\x20\x01(\x0cR\x04blob\"\x20\
    \n\x1eMoneroKeyImageSyncFinalRequest\"5\n\x1aMoneroKeyImageSyncFinalAck\
    \x12\x17\n\x07enc_key\x18\x01\x20\x01(\x0cR\x06encKey\"\x86\x01\n\x16Deb\
    ugMoneroDiagRequest\x12\x10\n\x03ins\x18\x01\x20\x01(\x04R\x03ins\x12\
    \x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02p1\x12\x0e\n\x02p2\x18\x03\x20\x01\
    (\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\x20\x03(\x04R\x02pd\x12\x14\n\x05da\
    ta1\x18\x05\x20\x01(\x0cR\x05data1\x12\x14\n\x05data2\x18\x06\x20\x01(\
    \x0cR\x05data2\"\x82\x01\n\x12DebugMoneroDiagAck\x12\x10\n\x03ins\x18\
    \x01\x20\x01(\x04R\x03ins\x12\x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02p1\
    \x12\x0e\n\x02p2\x18\x03\x20\x01(\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\x20\
    \x03(\x04R\x02pd\x12\x14\n\x05data1\x18\x05\x20\x01(\x0cR\x05data1\x12\
    \x14\n\x05data2\x18\x06\x20\x01(\x0cR\x05data2B:\n#com.satoshilabs.trezo\
    r.lib.protobufB\x13TrezorMessageMoneroJ\xa8\x87\x01\n\x07\x12\x05\0\0\
    \xbb\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\
    \0\"\n\x08\n\x01\x08\x12\x03\x04\0<\n.\n\x02\x08\x01\x12\x03\x04\0<\x1a#\
    \x20Sugar\x20for\x20easier\x20handling\x20in\x20Java\n\n\x08\n\x01\x08\
    \x12\x03\x05\04\n\t\n\x02\x08\x08\x12\x03\x05\04\nT\n\x02\x04\0\x12\x04\
    \x0b\0#\x01\x1aH*\n\x20Structure\x20representing\x20Monero\x20transactio\
    n\x20source\x20entry,\x20UTXO\n\x20@embed\n\n\n\n\x03\x04\0\x01\x12\x03\
    \x0b\x08$\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0c\x04+\n\x0c\n\x05\x04\0\x02\
    \0\x04\x12\x03\x0c\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0c\r\x1e\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\x1f&\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x0c)*\n\x0b\n\x04\x04\0\x02\x01\x12\x03\r\x04$\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\r\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\r\r\x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\r\x14\x1f\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\r\"#\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x0e\
    \x04'\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x0e\x04\x0c\n\x0c\n\x05\x04\
    \0\x02\x02\x05\x12\x03\x0e\r\x12\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\
    \x0e\x13\"\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0e%&\n\x0b\n\x04\x04\0\
    \x02\x03\x12\x03\x0f\x043\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0f\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0f\r\x12\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x0f\x13.\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f1\
    2\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x10\x040\n\x0c\n\x05\x04\0\x02\x04\
    \x04\x12\x03\x10\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x10\r\x13\
    \n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x10\x14+\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03\x10./\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x11\x04\x1f\n\
    \x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x11\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \x05\x05\x12\x03\x11\r\x13\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x11\x14\
    \x1a\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x11\x1d\x1e\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03\x12\x04\x1a\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x12\
    \x04\x0c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x12\r\x11\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03\x12\x12\x15\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x12\x18\x19\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x13\x04\x1c\n\x0c\n\x05\
    \x04\0\x02\x07\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\x07\x05\x12\
    \x03\x13\r\x12\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x13\x13\x17\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03\x13\x1a\x1b\n\x0b\n\x04\x04\0\x02\x08\x12\
    \x03\x14\x044\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x03\x14\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x08\x06\x12\x03\x14\r\x20\n\x0c\n\x05\x04\0\x02\x08\x01\
    \x12\x03\x14!/\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1423\n\x0c\n\x04\
    \x04\0\x03\0\x12\x04\x15\x04\x1c\x05\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\
    \x15\x0c\x1d\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\x16\x08\x20\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x04\x12\x03\x16\x08\x10\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x05\x12\x03\x16\x11\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x16\
    \x18\x1b\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x16\x1e\x1f\n\r\n\x06\
    \x04\0\x03\0\x02\x01\x12\x03\x17\x08&\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x03\x17\x08\x10\n\x0e\n\x07\x04\0\x03\0\x02\x01\x06\x12\x03\x17\
    \x11\x1d\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x17\x1e!\n\x0e\n\
    \x07\x04\0\x03\0\x02\x01\x03\x12\x03\x17$%\n\x0e\n\x06\x04\0\x03\0\x03\0\
    \x12\x04\x18\x08\x1b\t\n\x0e\n\x07\x04\0\x03\0\x03\0\x01\x12\x03\x18\x10\
    \x1c\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\0\x12\x03\x19\x0c$\n\x10\n\t\x04\
    \0\x03\0\x03\0\x02\0\x04\x12\x03\x19\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\0\x05\x12\x03\x19\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x01\x12\
    \x03\x19\x1b\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x03\x12\x03\x19\"#\n\
    \x0f\n\x08\x04\0\x03\0\x03\0\x02\x01\x12\x03\x1a\x0c$\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\x01\x04\x12\x03\x1a\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\x01\x05\x12\x03\x1a\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x01\
    \x12\x03\x1a\x1b\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x03\x12\x03\x1a\
    \"#\n\x0c\n\x04\x04\0\x03\x01\x12\x04\x1d\x04\"\x05\n\x0c\n\x05\x04\0\
    \x03\x01\x01\x12\x03\x1d\x0c\x1f\n\r\n\x06\x04\0\x03\x01\x02\0\x12\x03\
    \x1e\x08\x1d\n\x0e\n\x07\x04\0\x03\x01\x02\0\x04\x12\x03\x1e\x08\x10\n\
    \x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x03\x1e\x11\x16\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x01\x12\x03\x1e\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\0\
    \x03\x12\x03\x1e\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x03\x1f\x08\
    \x1d\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x03\x1f\x08\x10\n\x0e\n\
    \x07\x04\0\x03\x01\x02\x01\x05\x12\x03\x1f\x11\x16\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x01\x01\x12\x03\x1f\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x01\
    \x03\x12\x03\x1f\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x02\x12\x03\x20\x08\
    \x1d\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x04\x12\x03\x20\x08\x10\n\x0e\n\
    \x07\x04\0\x03\x01\x02\x02\x05\x12\x03\x20\x11\x16\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x02\x01\x12\x03\x20\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x02\
    \x03\x12\x03\x20\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x03\x12\x03!\x08\
    \x1e\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x04\x12\x03!\x08\x10\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x03\x05\x12\x03!\x11\x16\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x03\x01\x12\x03!\x17\x19\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x03\x12\
    \x03!\x1c\x1d\nS\n\x02\x04\x01\x12\x04)\04\x01\x1aG*\n\x20Structure\x20r\
    epresenting\x20Monero\x20transaction\x20destination\x20entry\n\x20@embed\
    \n\n\n\n\x03\x04\x01\x01\x12\x03)\x08)\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    *\x04\x1f\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03*\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03*\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03*\x14\
    \x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03*\x1d\x1e\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03+\x041\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03+\x04\x0c\
    \n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03+\r'\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03+(,\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03+/0\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x03,\x04$\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03,\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03,\r\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03,\x12\x1f\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03,\"#\n>\n\x04\x04\x01\x03\0\x12\x040\x043\x05\x1a0*\n\x20Structure\
    \x20representing\x20Monero\x20public\x20address\n\n\x0c\n\x05\x04\x01\
    \x03\0\x01\x12\x030\x0c&\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x031\x08,\n\
    \x0e\n\x07\x04\x01\x03\0\x02\0\x04\x12\x031\x08\x10\n\x0e\n\x07\x04\x01\
    \x03\0\x02\0\x05\x12\x031\x11\x16\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\
    \x12\x031\x17'\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x031*+\n\r\n\x06\
    \x04\x01\x03\0\x02\x01\x12\x032\x08+\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x04\x12\x032\x08\x10\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x032\x11\
    \x16\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x032\x17&\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x03\x12\x032)*\n,\n\x02\x04\x02\x12\x049\0G\x01\x1a\
    \x20*\n\x20Range\x20sig\x20parameters\x20/\x20data.\n\n\n\n\x03\x04\x02\
    \x01\x12\x039\x08!\n\x0b\n\x04\x04\x02\x02\0\x12\x03:\x04\x20\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03:\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03:\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03:\x14\x1b\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03:\x1e\x1f\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03;\x04\"\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03;\x04\x0c\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03;\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03;\x14\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x20!\n\x0b\n\x04\
    \x04\x02\x02\x02\x12\x03<\x04%\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03<\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03<\r\x13\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03<\x14\x20\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03<#$\n(\n\x04\x04\x02\x02\x03\x12\x03=\x04!\"\x1b\x20aggregation\x20s\
    cheme\x20for\x20BP\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03=\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x03\x05\x12\x03=\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03=\x14\x1c\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03=\x1f\
    \x20\n\x0b\n\x04\x04\x02\x02\x04\x12\x03?\x04\x1d\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03?\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03?\r\
    \x13\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03?\x14\x18\n\x0c\n\x05\x04\
    \x02\x02\x04\x03\x12\x03?\x1b\x1c\n\x0b\n\x04\x04\x02\x02\x05\x12\x03@\
    \x04\"\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03@\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x05\x05\x12\x03@\r\x13\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03@\
    \x14\x1d\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03@\x20!\n\x20\n\x04\x04\
    \x02\x02\x06\x12\x03A\x04\x1c\"\x13\x20determ.\x20mask\x20seed\n\n\x0c\n\
    \x05\x04\x02\x02\x06\x04\x12\x03A\x04\x0c\n\x0c\n\x05\x04\x02\x02\x06\
    \x05\x12\x03A\r\x12\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03A\x13\x17\n\
    \x0c\n\x05\x04\x02\x02\x06\x03\x12\x03A\x1a\x1b\n\x1a\n\x04\x04\x02\x02\
    \x07\x12\x03B\x04\x1c\"\r\x20mask\x20vector\n\n\x0c\n\x05\x04\x02\x02\
    \x07\x04\x12\x03B\x04\x0c\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03B\r\x12\
    \n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03B\x13\x17\n\x0c\n\x05\x04\x02\
    \x02\x07\x03\x12\x03B\x1a\x1b\n\x1c\n\x04\x04\x02\x02\x08\x12\x03C\x04\
    \x1e\"\x0f\x20amount\x20vector\n\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03\
    C\x04\x0c\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03C\r\x12\n\x0c\n\x05\x04\
    \x02\x02\x08\x01\x12\x03C\x13\x19\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\
    \x03C\x1c\x1d\n)\n\x04\x04\x02\x02\t\x12\x03D\x04\x1d\"\x1c\x20range\x20\
    sig,\x20full\x20or\x20partial\n\n\x0c\n\x05\x04\x02\x02\t\x04\x12\x03D\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03D\r\x12\n\x0c\n\x05\x04\
    \x02\x02\t\x01\x12\x03D\x13\x17\n\x0c\n\x05\x04\x02\x02\t\x03\x12\x03D\
    \x1a\x1c\n\x0b\n\x04\x04\x02\x02\n\x12\x03E\x04#\n\x0c\n\x05\x04\x02\x02\
    \n\x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03E\r\x12\n\
    \x0c\n\x05\x04\x02\x02\n\x01\x12\x03E\x13\x1d\n\x0c\n\x05\x04\x02\x02\n\
    \x03\x12\x03E\x20\"\n\x0b\n\x04\x04\x02\x02\x0b\x12\x03F\x04<\n\x0c\n\
    \x05\x04\x02\x02\x0b\x04\x12\x03F\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0b\
    \x06\x12\x03F\r.\n\x0c\n\x05\x04\x02\x02\x0b\x01\x12\x03F/6\n\x0c\n\x05\
    \x04\x02\x02\x0b\x03\x12\x03F9;\n\x82\x01\n\x02\x04\x03\x12\x04O\0U\x01\
    \x1av*\n\x20Request:\x20Ask\x20device\x20for\x20public\x20address\x20der\
    ived\x20from\x20seed\x20and\x20address_n\n\x20@start\n\x20@next\x20Moner\
    oAddress\n\x20@next\x20Failure\n\n\n\n\x03\x04\x03\x01\x12\x03O\x08\x18\
    \n=\n\x04\x04\x03\x02\0\x12\x03P\x04\"\"0\x20BIP-32\x20path\x20to\x20der\
    ive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x03P\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03P\r\x13\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03P\x14\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03P\x20!\nC\n\x04\x04\x03\x02\x01\x12\x03Q\x04#\"6\x20Optionally\
    \x20show\x20on\x20display\x20before\x20sending\x20the\x20result\n\n\x0c\
    \n\x05\x04\x03\x02\x01\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x03Q\r\x11\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03Q\x12\x1e\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03Q!\"\n,\n\x04\x04\x03\x02\x02\x12\
    \x03R\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stagenet\n\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03R\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03R\x14\x20\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03R#$\n\"\n\x04\x04\x03\x02\x03\x12\
    \x03S\x04\x20\"\x15\x20Major\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\
    \x02\x03\x04\x12\x03S\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03S\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03S\x14\x1b\n\x0c\n\x05\x04\
    \x03\x02\x03\x03\x12\x03S\x1e\x1f\n\"\n\x04\x04\x03\x02\x04\x12\x03T\x04\
    \x1e\"\x15\x20Minor\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\x02\x04\
    \x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03T\r\x13\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x03T\x14\x19\n\x0c\n\x05\x04\x03\x02\
    \x04\x03\x12\x03T\x1c\x1d\ng\n\x02\x04\x04\x12\x04[\0]\x01\x1a[*\n\x20Re\
    sponse:\x20Contains\x20Monero\x20watch-only\x20credentials\x20derived\
    \x20from\x20device\x20private\x20seed\n\x20@end\n\n\n\n\x03\x04\x04\x01\
    \x12\x03[\x08\x15\n\x0b\n\x04\x04\x04\x02\0\x12\x03\\\x04\x1f\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03\\\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03\\\r\x12\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\\\x13\x1a\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03\\\x1d\x1e\nk\n\x02\x04\x05\x12\x04e\0h\
    \x01\x1a_*\n\x20Request:\x20Ask\x20device\x20for\x20watch\x20only\x20cre\
    dentials\n\x20@start\n\x20@next\x20MoneroWatchKey\n\x20@next\x20Failure\
    \n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\x19\n=\n\x04\x04\x05\x02\0\x12\x03\
    f\x04\"\"0\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20ma\
    ster\x20node\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03f\x04\x0c\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03f\r\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03f\x14\x1d\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03f\x20!\n,\n\x04\x04\
    \x05\x02\x01\x12\x03g\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20sta\
    genet\n\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03g\r\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03g\
    \x14\x20\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03g#$\ng\n\x02\x04\x06\x12\
    \x04n\0q\x01\x1a[*\n\x20Response:\x20Contains\x20Monero\x20watch-only\
    \x20credentials\x20derived\x20from\x20device\x20private\x20seed\n\x20@en\
    d\n\n\n\n\x03\x04\x06\x01\x12\x03n\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03o\x04!\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03o\x04\x0c\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03o\r\x12\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03o\
    \x13\x1c\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03o\x1f\x20\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03p\x04\x1f\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03p\
    \x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03p\r\x12\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03p\x13\x1a\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03p\x1d\x1e\n\x88\x01\n\x02\x04\x07\x12\x05x\0\x91\x01\x01\x1a{*\n\x20\
    Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Initialize\
    s\x20transaction\x20signing.\n\x20@start\n\x20@next\x20MoneroTransaction\
    InitAck\n\n\n\n\x03\x04\x07\x01\x12\x03x\x08$\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03y\x04\x20\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03y\x04\x0c\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03y\r\x13\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03y\x14\x1b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03y\x1e\x1f\n\x0b\n\x04\
    \x04\x07\x02\x01\x12\x03z\x04\"\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03z\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03z\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03z\x14\x1d\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\
    \x03z\x20!\n,\n\x04\x04\x07\x02\x02\x12\x03{\x04%\"\x1f\x20Main-net\x20/\
    \x20testnet\x20/\x20stagenet\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03{\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03{\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03{\x14\x20\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03{#$\n\x0b\n\x04\x04\x07\x02\x03\x12\x03|\x040\n\x0c\n\x05\x04\x07\
    \x02\x03\x04\x12\x03|\x04\x0c\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03|\r\
    \"\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03|#+\n\x0c\n\x05\x04\x07\x02\
    \x03\x03\x12\x03|./\nQ\n\x04\x04\x07\x03\0\x12\x06\x80\x01\x04\x90\x01\
    \x05\x1aA*\n\x20Structure\x20representing\x20Monero\x20initial\x20transa\
    ction\x20information\n\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x80\x01\x0c!\
    \n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x81\x01\x08$\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x04\x12\x04\x81\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\
    \x02\0\x05\x12\x04\x81\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\
    \x12\x04\x81\x01\x18\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\x81\
    \x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\x82\x01\x08&\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x04\x12\x04\x82\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x05\x12\x04\x82\x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x01\x12\x04\x82\x01\x17!\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x03\
    \x12\x04\x82\x01$%\n\x0e\n\x06\x04\x07\x03\0\x02\x02\x12\x04\x83\x01\x08\
    (\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\x12\x04\x83\x01\x08\x10\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x02\x05\x12\x04\x83\x01\x11\x17\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x02\x01\x12\x04\x83\x01\x18#\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x02\x03\x12\x04\x83\x01&'\n\x0e\n\x06\x04\x07\x03\0\x02\x03\x12\x04\
    \x84\x01\x08?\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x04\x12\x04\x84\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x06\x12\x04\x84\x01\x112\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x03\x01\x12\x04\x84\x013:\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x03\x03\x12\x04\x84\x01=>\n\x0e\n\x06\x04\x07\x03\0\x02\x04\x12\
    \x04\x85\x01\x08B\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x04\x12\x04\x85\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x06\x12\x04\x85\x01\x112\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x04\x01\x12\x04\x85\x013=\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x04\x03\x12\x04\x85\x01@A\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x05\x12\x04\x86\x01\x08'\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x04\x12\x04\
    \x86\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x05\x12\x04\x86\x01\
    \x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x01\x12\x04\x86\x01\x18\"\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x05\x03\x12\x04\x86\x01%&\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x06\x12\x04\x87\x01\x08\"\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x06\x04\x12\x04\x87\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x05\
    \x12\x04\x87\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x01\x12\x04\
    \x87\x01\x18\x1d\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x03\x12\x04\x87\x01\
    \x20!\n\x0e\n\x06\x04\x07\x03\0\x02\x07\x12\x04\x88\x01\x08\x20\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x07\x04\x12\x04\x88\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x07\x05\x12\x04\x88\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x07\x01\x12\x04\x88\x01\x18\x1b\n\x0f\n\x07\x04\x07\x03\0\x02\x07\
    \x03\x12\x04\x88\x01\x1e\x1f\n\x0e\n\x06\x04\x07\x03\0\x02\x08\x12\x04\
    \x89\x01\x08$\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x04\x12\x04\x89\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x05\x12\x04\x89\x01\x11\x17\n\x0f\
    \n\x07\x04\x07\x03\0\x02\x08\x01\x12\x04\x89\x01\x18\x1f\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x08\x03\x12\x04\x89\x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\
    \t\x12\x04\x8a\x01\x08+\n\x0f\n\x07\x04\x07\x03\0\x02\t\x04\x12\x04\x8a\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\t\x05\x12\x04\x8a\x01\x11\x17\
    \n\x0f\n\x07\x04\x07\x03\0\x02\t\x01\x12\x04\x8a\x01\x18%\n\x0f\n\x07\
    \x04\x07\x03\0\x02\t\x03\x12\x04\x8a\x01(*\n\x0e\n\x06\x04\x07\x03\0\x02\
    \n\x12\x04\x8b\x01\x08'\n\x0f\n\x07\x04\x07\x03\0\x02\n\x04\x12\x04\x8b\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\n\x05\x12\x04\x8b\x01\x11\x15\
    \n\x0f\n\x07\x04\x07\x03\0\x02\n\x01\x12\x04\x8b\x01\x16!\n\x0f\n\x07\
    \x04\x07\x03\0\x02\n\x03\x12\x04\x8b\x01$&\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x0b\x12\x04\x8c\x01\x08/\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x04\x12\x04\
    \x8c\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x05\x12\x04\x8c\x01\
    \x11\x16\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x01\x12\x04\x8c\x01\x17)\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x0b\x03\x12\x04\x8c\x01,.\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x0c\x12\x04\x8d\x01\x08(\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x0c\x04\x12\x04\x8d\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x05\
    \x12\x04\x8d\x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x01\x12\x04\
    \x8d\x01\x17\"\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x03\x12\x04\x8d\x01%'\n\
    \x0e\n\x06\x04\x07\x03\0\x02\r\x12\x04\x8e\x01\x08:\n\x0f\n\x07\x04\x07\
    \x03\0\x02\r\x04\x12\x04\x8e\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\r\
    \x06\x12\x04\x8e\x01\x11*\n\x0f\n\x07\x04\x07\x03\0\x02\r\x01\x12\x04\
    \x8e\x01+4\n\x0f\n\x07\x04\x07\x03\0\x02\r\x03\x12\x04\x8e\x0179\n\x0e\n\
    \x06\x04\x07\x03\0\x02\x0e\x12\x04\x8f\x01\x080\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x0e\x04\x12\x04\x8f\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\
    \x05\x12\x04\x8f\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x01\x12\
    \x04\x8f\x01\x18*\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x03\x12\x04\x8f\x01-\
    /\ns\n\x02\x04\x08\x12\x06\x97\x01\0\x9f\x01\x01\x1ae*\n\x20Response:\
    \x20Response\x20to\x20transaction\x20signing\x20initialization.\n\x20@ne\
    xt\x20MoneroTransactionSetInputRequest\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \x97\x01\x08\x20\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x98\x01\x04\x20\n\r\n\
    \x05\x04\x08\x02\0\x04\x12\x04\x98\x01\x04\x0c\n\r\n\x05\x04\x08\x02\0\
    \x05\x12\x04\x98\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x98\x01\
    \x14\x1b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x98\x01\x1e\x1f\n\x0c\n\x04\
    \x04\x08\x02\x01\x12\x04\x99\x01\x04\x1f\n\r\n\x05\x04\x08\x02\x01\x04\
    \x12\x04\x99\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x99\x01\r\
    \x13\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x99\x01\x14\x1a\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\x99\x01\x1d\x1e\n\x0c\n\x04\x04\x08\x02\x02\x12\
    \x04\x9a\x01\x04\x20\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x9a\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x9a\x01\r\x11\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\x9a\x01\x12\x1b\n\r\n\x05\x04\x08\x02\x02\x03\
    \x12\x04\x9a\x01\x1e\x1f\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\x9b\x01\x04\
    \x1d\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\x9b\x01\x04\x0c\n\r\n\x05\x04\
    \x08\x02\x03\x05\x12\x04\x9b\x01\r\x12\n\r\n\x05\x04\x08\x02\x03\x01\x12\
    \x04\x9b\x01\x13\x18\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\x9b\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x9c\x01\x04\"\n\r\n\x05\x04\x08\
    \x02\x04\x04\x12\x04\x9c\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x04\x05\x12\
    \x04\x9c\x01\r\x11\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x9c\x01\x12\x1d\
    \n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x9c\x01\x20!\n\x0c\n\x04\x04\x08\
    \x02\x05\x12\x04\x9d\x01\x04#\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\x9d\
    \x01\x04\x0c\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\x9d\x01\r\x11\n\r\n\
    \x05\x04\x08\x02\x05\x01\x12\x04\x9d\x01\x12\x1e\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\x9d\x01!\"\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\x9e\x01\
    \x045\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\x9e\x01\x04\x0c\n\r\n\x05\
    \x04\x08\x02\x06\x06\x12\x04\x9e\x01\r&\n\r\n\x05\x04\x08\x02\x06\x01\
    \x12\x04\x9e\x01'0\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\x9e\x0134\n}\n\
    \x02\x04\t\x12\x06\xa5\x01\0\xa8\x01\x01\x1ao*\n\x20Request:\x20Sub\x20r\
    equest\x20of\x20MoneroTransactionSign.\x20Sends\x20one\x20UTXO\x20to\x20\
    device\n\x20@next\x20MoneroTransactionSetInputAck\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\xa5\x01\x08(\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa6\x01\x04\
    \x20\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa6\x01\x04\x0c\n\r\n\x05\x04\t\
    \x02\0\x05\x12\x04\xa6\x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa6\
    \x01\x14\x1b\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa6\x01\x1e\x1f\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xa7\x01\x047\n\r\n\x05\x04\t\x02\x01\x04\x12\
    \x04\xa7\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xa7\x01\r)\n\r\
    \n\x05\x04\t\x02\x01\x01\x12\x04\xa7\x01*2\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xa7\x0156\n\xd3\x01\n\x02\x04\n\x12\x06\xaf\x01\0\xb6\x01\x01\
    \x1a\xc4\x01*\n\x20Response:\x20Response\x20to\x20setting\x20UTXO\x20for\
    \x20signature.\x20Contains\x20sealed\x20values\x20needed\x20for\x20furth\
    er\x20protocol\x20steps.\n\x20@next\x20MoneroTransactionSetInputAck\n\
    \x20@next\x20MoneroTransactionInputsPermutationRequest\n\n\x0b\n\x03\x04\
    \n\x01\x12\x04\xaf\x01\x08$\n\"\n\x04\x04\n\x02\0\x12\x04\xb0\x01\x04\
    \x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb0\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xb0\x01\r\x12\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xb0\x01\x13\x17\n\r\n\x05\x04\n\x02\0\x03\x12\
    \x04\xb0\x01\x1a\x1b\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xb1\x01\x04!\n\r\
    \n\x05\x04\n\x02\x01\x04\x12\x04\xb1\x01\x04\x0c\n\r\n\x05\x04\n\x02\x01\
    \x05\x12\x04\xb1\x01\r\x12\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xb1\x01\
    \x13\x1c\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xb1\x01\x1f\x20\n\x0c\n\x04\
    \x04\n\x02\x02\x12\x04\xb2\x01\x04\"\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\
    \xb2\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xb2\x01\r\x12\n\r\n\
    \x05\x04\n\x02\x02\x01\x12\x04\xb2\x01\x13\x1d\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\xb2\x01\x20!\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xb3\x01\x04'\
    \n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xb3\x01\x04\x0c\n\r\n\x05\x04\n\x02\
    \x03\x05\x12\x04\xb3\x01\r\x12\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xb3\
    \x01\x13\"\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xb3\x01%&\n\x0c\n\x04\x04\
    \n\x02\x04\x12\x04\xb4\x01\x04!\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xb4\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xb4\x01\r\x12\n\r\n\x05\
    \x04\n\x02\x04\x01\x12\x04\xb4\x01\x13\x1c\n\r\n\x05\x04\n\x02\x04\x03\
    \x12\x04\xb4\x01\x1f\x20\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xb5\x01\x04!\
    \n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xb5\x01\x04\x0c\n\r\n\x05\x04\n\x02\
    \x05\x05\x12\x04\xb5\x01\r\x12\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xb5\
    \x01\x13\x1c\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xb5\x01\x1f\x20\n\x88\
    \x01\n\x02\x04\x0b\x12\x06\xbc\x01\0\xbe\x01\x01\x1az*\n\x20Request:\x20\
    Sub\x20request\x20of\x20MoneroTransactionSign.\x20Permutation\x20on\x20k\
    ey\x20images.\n\x20@next\x20MoneroTransactionInputsPermutationAck\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\xbc\x01\x081\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\xbd\x01\x04\x1d\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xbd\x01\x04\
    \x0c\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xbd\x01\r\x13\n\r\n\x05\x04\x0b\
    \x02\0\x01\x12\x04\xbd\x01\x14\x18\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \xbd\x01\x1b\x1c\nr\n\x02\x04\x0c\x12\x06\xc4\x01\0\xc5\x01\x01\x1ad*\n\
    \x20Response:\x20Response\x20to\x20setting\x20permutation\x20on\x20key\
    \x20images\n\x20@next\x20MoneroTransactionInputViniRequest\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xc4\x01\x08-\n\x9c\x01\n\x02\x04\r\x12\x06\xcb\x01\
    \0\xd1\x01\x01\x1a\x8d\x01*\n\x20Request:\x20Sub\x20request\x20of\x20Mon\
    eroTransactionSign.\x20Sends\x20one\x20UTXO\x20to\x20device\x20together\
    \x20with\x20sealed\x20values.\n\x20@next\x20MoneroTransactionInputViniAc\
    k\n\n\x0b\n\x03\x04\r\x01\x12\x04\xcb\x01\x08)\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\xcc\x01\x047\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xcc\x01\x04\x0c\
    \n\r\n\x05\x04\r\x02\0\x06\x12\x04\xcc\x01\r)\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xcc\x01*2\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xcc\x0156\n\"\n\x04\
    \x04\r\x02\x01\x12\x04\xcd\x01\x04\x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\
    \n\x05\x04\r\x02\x01\x04\x12\x04\xcd\x01\x04\x0c\n\r\n\x05\x04\r\x02\x01\
    \x05\x12\x04\xcd\x01\r\x12\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xcd\x01\
    \x13\x17\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xcd\x01\x1a\x1b\n\x0c\n\x04\
    \x04\r\x02\x02\x12\x04\xce\x01\x04!\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\
    \xce\x01\x04\x0c\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xce\x01\r\x12\n\r\n\
    \x05\x04\r\x02\x02\x01\x12\x04\xce\x01\x13\x1c\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\xce\x01\x1f\x20\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xcf\x01\
    \x04\"\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xcf\x01\x04\x0c\n\r\n\x05\x04\
    \r\x02\x03\x05\x12\x04\xcf\x01\r\x12\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xcf\x01\x13\x1d\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xcf\x01\x20!\n\x0c\
    \n\x04\x04\r\x02\x04\x12\x04\xd0\x01\x04'\n\r\n\x05\x04\r\x02\x04\x04\
    \x12\x04\xd0\x01\x04\x0c\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xd0\x01\r\
    \x12\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xd0\x01\x13\"\n\r\n\x05\x04\r\
    \x02\x04\x03\x12\x04\xd0\x01%&\n\x98\x01\n\x02\x04\x0e\x12\x06\xd8\x01\0\
    \xd9\x01\x01\x1a\x89\x01*\n\x20Response:\x20Response\x20to\x20setting\
    \x20UTXO\x20to\x20the\x20device\n\x20@next\x20MoneroTransactionInputVini\
    Request\n\x20@next\x20MoneroTransactionAllInputsSetRequest\n\n\x0b\n\x03\
    \x04\x0e\x01\x12\x04\xd8\x01\x08%\n\xaf\x01\n\x02\x04\x0f\x12\x06\xdf\
    \x01\0\xe1\x01\x01\x1a\xa0\x01*\n\x20Request:\x20Sub\x20request\x20of\
    \x20MoneroTransactionSign.\x20Sent\x20after\x20all\x20inputs\x20have\x20\
    been\x20sent.\x20Useful\x20for\x20rangeisg\x20offloading.\n\x20@next\x20\
    MoneroTransactionAllInputsSetAck\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xdf\
    \x01\x08,\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xe0\x01\x045\n\r\n\x05\x04\
    \x0f\x02\0\x04\x12\x04\xe0\x01\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\
    \x04\xe0\x01\r&\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xe0\x01'0\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xe0\x0134\np\n\x02\x04\x10\x12\x06\xe7\x01\0\
    \xe9\x01\x01\x1ab*\n\x20Response:\x20Response\x20to\x20after\x20all\x20i\
    nputs\x20have\x20been\x20set.\n\x20@next\x20MoneroTransactionSetOutputRe\
    quest\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xe7\x01\x08(\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xe8\x01\x045\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe8\x01\
    \x04\x0c\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xe8\x01\r&\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xe8\x01'0\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe8\
    \x0134\n\x9b\x01\n\x02\x04\x11\x12\x06\xef\x01\0\xf3\x01\x01\x1a\x8c\x01\
    *\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Sen\
    ds\x20one\x20transaction\x20destination\x20to\x20device\x20(HMACed)\n\
    \x20@next\x20MoneroTransactionSetOutputAck\n\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xef\x01\x08)\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xf0\x01\x04<\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\
    \x06\x12\x04\xf0\x01\r.\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xf0\x01/7\n\
    \r\n\x05\x04\x11\x02\0\x03\x12\x04\xf0\x01:;\n\x0c\n\x04\x04\x11\x02\x01\
    \x12\x04\xf1\x01\x04%\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xf1\x01\x04\
    \x0c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xf1\x01\r\x12\n\r\n\x05\x04\
    \x11\x02\x01\x01\x12\x04\xf1\x01\x13\x20\n\r\n\x05\x04\x11\x02\x01\x03\
    \x12\x04\xf1\x01#$\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xf2\x01\x045\n\r\
    \n\x05\x04\x11\x02\x02\x04\x12\x04\xf2\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x02\x06\x12\x04\xf2\x01\r&\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xf2\
    \x01'0\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xf2\x0134\n\xd5\x01\n\x02\
    \x04\x12\x12\x06\xfa\x01\0\x80\x02\x01\x1a\xc6\x01*\n\x20Response:\x20Re\
    sponse\x20to\x20setting\x20transaction\x20destination.\x20Contains\x20se\
    aled\x20values\x20needed\x20for\x20further\x20protocol\x20steps.\n\x20@n\
    ext\x20MoneroTransactionSetOutputRequest\n\x20@next\x20MoneroTransaction\
    AllOutSetRequest\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xfa\x01\x08%\n\x1e\n\
    \x04\x04\x12\x02\0\x12\x04\xfb\x01\x04\x1e\"\x10\x20xmrtypes.TxOut\n\n\r\
    \n\x05\x04\x12\x02\0\x04\x12\x04\xfb\x01\x04\x0c\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xfb\x01\r\x12\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xfb\x01\
    \x13\x19\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xfb\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xfc\x01\x04\"\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xfc\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xfc\x01\r\x12\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xfc\x01\x13\x1d\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xfc\x01\x20!\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\
    \xfd\x01\x045\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xfd\x01\x04\x0c\n\r\
    \n\x05\x04\x12\x02\x02\x06\x12\x04\xfd\x01\r&\n\r\n\x05\x04\x12\x02\x02\
    \x01\x12\x04\xfd\x01'0\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xfd\x0134\n\
    \x0c\n\x04\x04\x12\x02\x03\x12\x04\xfe\x01\x04\x1e\n\r\n\x05\x04\x12\x02\
    \x03\x04\x12\x04\xfe\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\
    \xfe\x01\r\x12\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xfe\x01\x13\x19\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\xfe\x01\x1c\x1d\n\x0c\n\x04\x04\x12\
    \x02\x04\x12\x04\xff\x01\x04!\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xff\
    \x01\x04\x0c\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xff\x01\r\x12\n\r\n\
    \x05\x04\x12\x02\x04\x01\x12\x04\xff\x01\x13\x1c\n\r\n\x05\x04\x12\x02\
    \x04\x03\x12\x04\xff\x01\x1f\x20\n\x86\x01\n\x02\x04\x13\x12\x06\x86\x02\
    \0\x88\x02\x01\x1ax*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTran\
    sactionSign.\x20Sent\x20after\x20all\x20outputs\x20are\x20sent.\n\x20@ne\
    xt\x20MoneroTransactionAllOutSetAck\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \x86\x02\x08)\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x87\x02\x045\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\x87\x02\x04\x0c\n\r\n\x05\x04\x13\x02\0\x06\
    \x12\x04\x87\x02\r&\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x87\x02'0\n\r\n\
    \x05\x04\x13\x02\0\x03\x12\x04\x87\x0234\n\x8a\x01\n\x02\x04\x14\x12\x06\
    \x8e\x02\0\x9b\x02\x01\x1a|*\n\x20Response:\x20After\x20all\x20outputs\
    \x20are\x20sent\x20the\x20initial\x20RCT\x20signature\x20fields\x20are\
    \x20sent.\n\x20@next\x20MoneroTransactionMlsagDoneRequest\n\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\x8e\x02\x08%\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x8f\
    \x02\x04\x1d\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x8f\x02\x04\x0c\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\x8f\x02\r\x12\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\x8f\x02\x13\x18\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x8f\x02\x1b\
    \x1c\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x90\x02\x04&\n\r\n\x05\x04\x14\
    \x02\x01\x04\x12\x04\x90\x02\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\x90\x02\r\x12\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x90\x02\x13!\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\x90\x02$%\n\x0c\n\x04\x04\x14\x02\
    \x02\x12\x04\x91\x02\x045\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x91\x02\
    \x04\x0c\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\x91\x02\r&\n\r\n\x05\x04\
    \x14\x02\x02\x01\x12\x04\x91\x02'0\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \x91\x0234\n\x1f\n\x04\x04\x14\x02\x03\x12\x04\x92\x02\x04$\"\x11\x20xmr\
    types.RctSig\n\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\x92\x02\x04\x0c\n\r\
    \n\x05\x04\x14\x02\x03\x06\x12\x04\x92\x02\r\x1c\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\x92\x02\x1d\x1f\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\
    \x92\x02\"#\nR\n\x04\x04\x14\x03\0\x12\x06\x96\x02\x04\x9a\x02\x05\x1aB\
    \n\x20Structure\x20represents\x20initial\x20fields\x20of\x20the\x20Moner\
    o\x20RCT\x20signature\n\n\r\n\x05\x04\x14\x03\0\x01\x12\x04\x96\x02\x0c\
    \x1b\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\x97\x02\x08$\n\x0f\n\x07\
    \x04\x14\x03\0\x02\0\x04\x12\x04\x97\x02\x08\x10\n\x0f\n\x07\x04\x14\x03\
    \0\x02\0\x05\x12\x04\x97\x02\x11\x17\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\
    \x12\x04\x97\x02\x18\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\0\x03\x12\x04\x97\
    \x02\"#\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x98\x02\x08#\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x01\x04\x12\x04\x98\x02\x08\x10\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x01\x05\x12\x04\x98\x02\x11\x16\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x01\x01\x12\x04\x98\x02\x17\x1e\n\x0f\n\x07\x04\x14\x03\0\x02\x01\
    \x03\x12\x04\x98\x02!\"\n\x0e\n\x06\x04\x14\x03\0\x02\x02\x12\x04\x99\
    \x02\x08$\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\x99\x02\x08\x10\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\x99\x02\x11\x17\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x02\x01\x12\x04\x99\x02\x18\x1f\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x02\x03\x12\x04\x99\x02\"#\ne\n\x02\x04\x15\x12\x06\xa1\
    \x02\0\xa2\x02\x01\x1aW*\n\x20Request:\x20Sub\x20request\x20of\x20Monero\
    TransactionSign.\n\x20@next\x20MoneroTransactionMlsagDoneAck\n\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xa1\x02\x08)\nx\n\x02\x04\x16\x12\x06\xa8\x02\0\
    \xaa\x02\x01\x1aj*\n\x20Response:\x20Contains\x20full\x20message\x20hash\
    \x20needed\x20for\x20the\x20signature\n\x20@next\x20MoneroTransactionSig\
    nInputRequest\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xa8\x02\x08%\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\xa9\x02\x04)\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xa9\x02\x04\x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa9\x02\r\x12\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xa9\x02\x13$\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa9\x02'(\n\x81\x01\n\x02\x04\x17\x12\x06\xb0\x02\0\xb8\x02\x01\
    \x1as*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\
    \x20Sends\x20UTXO\x20for\x20the\x20signing.\n\x20@next\x20MoneroTransact\
    ionSignInputAck\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xb0\x02\x08)\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xb1\x02\x047\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xb1\x02\x04\x0c\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xb1\x02\r)\n\r\
    \n\x05\x04\x17\x02\0\x01\x12\x04\xb1\x02*2\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\xb1\x0256\n\"\n\x04\x04\x17\x02\x01\x12\x04\xb2\x02\x04\x1c\"\
    \x14\x20xmrtypes.TxinToKey\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xb2\
    \x02\x04\x0c\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xb2\x02\r\x12\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xb2\x02\x13\x17\n\r\n\x05\x04\x17\x02\
    \x01\x03\x12\x04\xb2\x02\x1a\x1b\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xb3\
    \x02\x04!\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xb3\x02\x04\x0c\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\xb3\x02\r\x12\n\r\n\x05\x04\x17\x02\x02\
    \x01\x12\x04\xb3\x02\x13\x1c\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xb3\
    \x02\x1f\x20\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xb4\x02\x04\"\n\r\n\x05\
    \x04\x17\x02\x03\x04\x12\x04\xb4\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x03\
    \x05\x12\x04\xb4\x02\r\x12\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xb4\x02\
    \x13\x1d\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xb4\x02\x20!\n\x0c\n\x04\
    \x04\x17\x02\x04\x12\x04\xb5\x02\x04'\n\r\n\x05\x04\x17\x02\x04\x04\x12\
    \x04\xb5\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xb5\x02\r\x12\
    \n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xb5\x02\x13\"\n\r\n\x05\x04\x17\
    \x02\x04\x03\x12\x04\xb5\x02%&\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xb6\
    \x02\x04!\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\xb6\x02\x04\x0c\n\r\n\
    \x05\x04\x17\x02\x05\x05\x12\x04\xb6\x02\r\x12\n\r\n\x05\x04\x17\x02\x05\
    \x01\x12\x04\xb6\x02\x13\x1c\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xb6\
    \x02\x1f\x20\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xb7\x02\x04!\n\r\n\x05\
    \x04\x17\x02\x06\x04\x12\x04\xb7\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x06\
    \x05\x12\x04\xb7\x02\r\x12\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xb7\x02\
    \x13\x1c\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xb7\x02\x1f\x20\n\xb0\x01\
    \n\x02\x04\x18\x12\x06\xbf\x02\0\xc2\x02\x01\x1a\xa1\x01*\n\x20Response:\
    \x20Contains\x20full\x20MG\x20signature\x20of\x20the\x20UTXO\x20+\x20mul\
    tisig\x20data\x20if\x20applicable.\n\x20@next\x20MoneroTransactionSignIn\
    putRequest\n\x20@next\x20MoneroTransactionFinalRequest\n\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xbf\x02\x08%\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xc0\x02\
    \x04!\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xc0\x02\x04\x0c\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\xc0\x02\r\x12\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xc0\x02\x13\x1c\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc0\x02\x1f\x20\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\xc1\x02\x04\x1c\n\r\n\x05\x04\x18\x02\
    \x01\x04\x12\x04\xc1\x02\x04\x0c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\
    \xc1\x02\r\x12\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc1\x02\x13\x17\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\xc1\x02\x1a\x1b\n\x99\x01\n\x02\x04\
    \x19\x12\x06\xc8\x02\0\xc9\x02\x01\x1a\x8a\x01*\n\x20Request:\x20Sub\x20\
    request\x20of\x20MoneroTransactionSign.\x20Final\x20message\x20of\x20the\
    \x20procol\x20after\x20all\x20UTXOs\x20are\x20signed\n\x20@next\x20Moner\
    oTransactionFinalAck\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xc8\x02\x08%\n\
    \x9b\x01\n\x02\x04\x1a\x12\x06\xcf\x02\0\xd4\x02\x01\x1a\x8c\x01*\n\x20R\
    esponse:\x20Contains\x20transaction\x20metadata\x20and\x20encryption\x20\
    keys\x20needed\x20for\x20further\x20transaction\x20operations\x20(e.g.\
    \x20multisig,\x20send\x20proof).\n\x20@end\n\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xcf\x02\x08!\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd0\x02\x04\x20\n\r\
    \n\x05\x04\x1a\x02\0\x04\x12\x04\xd0\x02\x04\x0c\n\r\n\x05\x04\x1a\x02\0\
    \x05\x12\x04\xd0\x02\r\x12\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd0\x02\
    \x13\x1b\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd0\x02\x1e\x1f\n\x0c\n\x04\
    \x04\x1a\x02\x01\x12\x04\xd1\x02\x04\x1c\n\r\n\x05\x04\x1a\x02\x01\x04\
    \x12\x04\xd1\x02\x04\x0c\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xd1\x02\r\
    \x12\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd1\x02\x13\x17\n\r\n\x05\x04\
    \x1a\x02\x01\x03\x12\x04\xd1\x02\x1a\x1b\n\x0c\n\x04\x04\x1a\x02\x02\x12\
    \x04\xd2\x02\x04!\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xd2\x02\x04\x0c\
    \n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xd2\x02\r\x12\n\r\n\x05\x04\x1a\
    \x02\x02\x01\x12\x04\xd2\x02\x13\x1c\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\xd2\x02\x1f\x20\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xd3\x02\x04#\n\
    \r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x1a\
    \x02\x03\x05\x12\x04\xd3\x02\r\x12\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\
    \xd3\x02\x13\x1e\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xd3\x02!\"\n\x85\
    \x01\n\x02\x04\x1b\x12\x06\xdb\x02\0\xe8\x02\x01\x1aw*\n\x20Request:\x20\
    Sub\x20request\x20of\x20MoneroKeyImageSync.\x20Initializing\x20key\x20im\
    age\x20sync.\n\x20@start\n\x20@next\x20MoneroKeyImageExportInitAck\n\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xdb\x02\x08'\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xdc\x02\x04\x1c\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xdc\x02\x04\
    \x0c\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xdc\x02\r\x13\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xdc\x02\x14\x17\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\
    \xdc\x02\x1a\x1b\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xdd\x02\x04\x1c\n\r\
    \n\x05\x04\x1b\x02\x01\x04\x12\x04\xdd\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xdd\x02\r\x12\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xdd\
    \x02\x13\x17\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xdd\x02\x1a\x1b\n>\n\
    \x04\x04\x1b\x02\x02\x12\x04\xde\x02\x04\"\"0\x20BIP-32\x20path\x20to\
    \x20derive\x20the\x20key\x20from\x20master\x20node\n\n\r\n\x05\x04\x1b\
    \x02\x02\x04\x12\x04\xde\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\x02\x05\x12\
    \x04\xde\x02\r\x13\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xde\x02\x14\x1d\
    \n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xde\x02\x20!\n-\n\x04\x04\x1b\x02\
    \x03\x12\x04\xdf\x02\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stag\
    enet\n\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xdf\x02\x04\x0c\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xdf\x02\r\x13\n\r\n\x05\x04\x1b\x02\x03\x01\
    \x12\x04\xdf\x02\x14\x20\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xdf\x02#$\
    \n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xe0\x02\x042\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xe0\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\x04\x06\x12\x04\
    \xe0\x02\r(\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xe0\x02)-\n\r\n\x05\
    \x04\x1b\x02\x04\x03\x12\x04\xe0\x0201\nG\n\x04\x04\x1b\x03\0\x12\x06\
    \xe4\x02\x04\xe7\x02\x05\x1a7*\n\x20Structure\x20representing\x20Monero\
    \x20list\x20of\x20sub-addresses\n\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\
    \xe4\x02\x0c'\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\x04\xe5\x02\x08$\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xe5\x02\x08\x10\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\0\x05\x12\x04\xe5\x02\x11\x17\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\0\x01\x12\x04\xe5\x02\x18\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\
    \x12\x04\xe5\x02\"#\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\x12\x04\xe6\x02\
    \x08*\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xe6\x02\x08\x10\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xe6\x02\x11\x17\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\x01\x01\x12\x04\xe6\x02\x18%\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x01\x03\x12\x04\xe6\x02()\nk\n\x02\x04\x1c\x12\x06\xee\x02\0\xef\
    \x02\x01\x1a]*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\
    \x20initialization.\n\x20@next\x20MoneroKeyImageSyncStepRequest\n\n\x0b\
    \n\x03\x04\x1c\x01\x12\x04\xee\x02\x08#\n\x93\x01\n\x02\x04\x1d\x12\x06\
    \xf5\x02\0\x80\x03\x01\x1a\x84\x01*\n\x20Request:\x20Sub\x20request\x20o\
    f\x20MoneroKeyImageSync.\x20Contains\x20batch\x20of\x20the\x20UTXO\x20to\
    \x20export\x20key\x20image\x20for.\n\x20@next\x20MoneroKeyImageSyncStepA\
    ck\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf5\x02\x08%\n\x0c\n\x04\x04\x1d\
    \x02\0\x12\x04\xf6\x02\x04,\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xf6\x02\
    \x04\x0c\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xf6\x02\r\"\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xf6\x02#'\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf6\
    \x02*+\nI\n\x04\x04\x1d\x03\0\x12\x06\xfa\x02\x04\xff\x02\x05\x1a9*\n\
    \x20Structure\x20representing\x20Monero\x20UTXO\x20for\x20key\x20image\
    \x20sync\n\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\xfa\x02\x0c!\n\x0e\n\x06\
    \x04\x1d\x03\0\x02\0\x12\x04\xfb\x02\x08#\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \0\x04\x12\x04\xfb\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\
    \x04\xfb\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xfb\x02\
    \x17\x1e\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xfb\x02!\"\n\x0e\n\
    \x06\x04\x1d\x03\0\x02\x01\x12\x04\xfc\x02\x08&\n\x0f\n\x07\x04\x1d\x03\
    \0\x02\x01\x04\x12\x04\xfc\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\
    \x05\x12\x04\xfc\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\
    \x04\xfc\x02\x17!\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\xfc\x02$\
    %\n\x0e\n\x06\x04\x1d\x03\0\x02\x02\x12\x04\xfd\x02\x082\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x02\x04\x12\x04\xfd\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x02\x05\x12\x04\xfd\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\
    \x01\x12\x04\xfd\x02\x17-\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\
    \xfd\x0201\n\x0e\n\x06\x04\x1d\x03\0\x02\x03\x12\x04\xfe\x02\x082\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x03\x04\x12\x04\xfe\x02\x08\x10\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x03\x05\x12\x04\xfe\x02\x11\x17\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x03\x01\x12\x04\xfe\x02\x18-\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x03\
    \x12\x04\xfe\x0201\n\xaf\x01\n\x02\x04\x1e\x12\x06\x87\x03\0\x91\x03\x01\
    \x1a\xa0\x01*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\
    \x20step.\x20Contains\x20encrypted\x20exported\x20key\x20image.\n\x20@ne\
    xt\x20MoneroKeyImageSyncStepRequest\n\x20@next\x20MoneroKeyImageSyncFina\
    lRequest\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x87\x03\x08!\n\x0c\n\x04\x04\
    \x1e\x02\0\x12\x04\x88\x03\x04,\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\x88\
    \x03\x04\x0c\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\x88\x03\r#\n\r\n\x05\
    \x04\x1e\x02\0\x01\x12\x04\x88\x03$'\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \x88\x03*+\nN\n\x04\x04\x1e\x03\0\x12\x06\x8c\x03\x04\x90\x03\x05\x1a>*\
    \n\x20Structure\x20representing\x20Monero\x20encrypted\x20exported\x20ke\
    y\x20image\n\n\r\n\x05\x04\x1e\x03\0\x01\x12\x04\x8c\x03\x0c\"\n\x0e\n\
    \x06\x04\x1e\x03\0\x02\0\x12\x04\x8d\x03\x08\x1e\n\x0f\n\x07\x04\x1e\x03\
    \0\x02\0\x04\x12\x04\x8d\x03\x08\x10\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x05\
    \x12\x04\x8d\x03\x11\x16\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x01\x12\x04\x8d\
    \x03\x17\x19\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x03\x12\x04\x8d\x03\x1c\x1d\
    \n\x0e\n\x06\x04\x1e\x03\0\x02\x01\x12\x04\x8e\x03\x08\x1f\n\x0f\n\x07\
    \x04\x1e\x03\0\x02\x01\x04\x12\x04\x8e\x03\x08\x10\n\x0f\n\x07\x04\x1e\
    \x03\0\x02\x01\x05\x12\x04\x8e\x03\x11\x16\n\x0f\n\x07\x04\x1e\x03\0\x02\
    \x01\x01\x12\x04\x8e\x03\x17\x1a\n\x0f\n\x07\x04\x1e\x03\0\x02\x01\x03\
    \x12\x04\x8e\x03\x1d\x1e\n\x0e\n\x06\x04\x1e\x03\0\x02\x02\x12\x04\x8f\
    \x03\x08\x20\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x04\x12\x04\x8f\x03\x08\
    \x10\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x05\x12\x04\x8f\x03\x11\x16\n\x0f\
    \n\x07\x04\x1e\x03\0\x02\x02\x01\x12\x04\x8f\x03\x17\x1b\n\x0f\n\x07\x04\
    \x1e\x03\0\x02\x02\x03\x12\x04\x8f\x03\x1e\x1f\n\x83\x01\n\x02\x04\x1f\
    \x12\x06\x97\x03\0\x98\x03\x01\x1au*\n\x20Request:\x20Sub\x20request\x20\
    of\x20MoneroKeyImageSync.\x20Final\x20message\x20of\x20the\x20sync\x20pr\
    otocol.\n\x20@next\x20MoneroKeyImageSyncFinalAck\n\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\x97\x03\x08&\nt\n\x02\x04\x20\x12\x06\x9e\x03\0\xa0\x03\x01\
    \x1af*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\x20step.\
    \x20Contains\x20encryption\x20keys\x20for\x20exported\x20key\x20images.\
    \n\x20@end\n\n\x0b\n\x03\x04\x20\x01\x12\x04\x9e\x03\x08\"\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\x9f\x03\x04\x1f\n\r\n\x05\x04\x20\x02\0\x04\x12\
    \x04\x9f\x03\x04\x0c\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x9f\x03\r\x12\n\
    \r\n\x05\x04\x20\x02\0\x01\x12\x04\x9f\x03\x13\x1a\n\r\n\x05\x04\x20\x02\
    \0\x03\x12\x04\x9f\x03\x1d\x1e\nx\n\x02\x04!\x12\x06\xa7\x03\0\xae\x03\
    \x01\x1aj*\n\x20Request:\x20Universal\x20Monero\x20protocol\x20implement\
    ation\x20diagnosis\x20request.\n\x20@start\n\x20@next\x20DebugMoneroDiag\
    Ack\n\n\x0b\n\x03\x04!\x01\x12\x04\xa7\x03\x08\x1e\n\x0c\n\x04\x04!\x02\
    \0\x12\x04\xa8\x03\x04\x1c\n\r\n\x05\x04!\x02\0\x04\x12\x04\xa8\x03\x04\
    \x0c\n\r\n\x05\x04!\x02\0\x05\x12\x04\xa8\x03\r\x13\n\r\n\x05\x04!\x02\0\
    \x01\x12\x04\xa8\x03\x14\x17\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa8\x03\
    \x1a\x1b\n\x0c\n\x04\x04!\x02\x01\x12\x04\xa9\x03\x04\x1b\n\r\n\x05\x04!\
    \x02\x01\x04\x12\x04\xa9\x03\x04\x0c\n\r\n\x05\x04!\x02\x01\x05\x12\x04\
    \xa9\x03\r\x13\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xa9\x03\x14\x16\n\r\n\
    \x05\x04!\x02\x01\x03\x12\x04\xa9\x03\x19\x1a\n\x0c\n\x04\x04!\x02\x02\
    \x12\x04\xaa\x03\x04\x1b\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xaa\x03\x04\
    \x0c\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xaa\x03\r\x13\n\r\n\x05\x04!\x02\
    \x02\x01\x12\x04\xaa\x03\x14\x16\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xaa\
    \x03\x19\x1a\n\x0c\n\x04\x04!\x02\x03\x12\x04\xab\x03\x04\x1b\n\r\n\x05\
    \x04!\x02\x03\x04\x12\x04\xab\x03\x04\x0c\n\r\n\x05\x04!\x02\x03\x05\x12\
    \x04\xab\x03\r\x13\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xab\x03\x14\x16\n\
    \r\n\x05\x04!\x02\x03\x03\x12\x04\xab\x03\x19\x1a\n\x0c\n\x04\x04!\x02\
    \x04\x12\x04\xac\x03\x04\x1d\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xac\x03\
    \x04\x0c\n\r\n\x05\x04!\x02\x04\x05\x12\x04\xac\x03\r\x12\n\r\n\x05\x04!\
    \x02\x04\x01\x12\x04\xac\x03\x13\x18\n\r\n\x05\x04!\x02\x04\x03\x12\x04\
    \xac\x03\x1b\x1c\n\x0c\n\x04\x04!\x02\x05\x12\x04\xad\x03\x04\x1d\n\r\n\
    \x05\x04!\x02\x05\x04\x12\x04\xad\x03\x04\x0c\n\r\n\x05\x04!\x02\x05\x05\
    \x12\x04\xad\x03\r\x12\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xad\x03\x13\
    \x18\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xad\x03\x1b\x1c\nH\n\x02\x04\"\
    \x12\x06\xb4\x03\0\xbb\x03\x01\x1a:*\n\x20Response:\x20Response\x20to\
    \x20Monero\x20diagnosis\x20protocol.\n\x20@end\n\n\x0b\n\x03\x04\"\x01\
    \x12\x04\xb4\x03\x08\x1a\n\x0c\n\x04\x04\"\x02\0\x12\x04\xb5\x03\x04\x1c\
    \n\r\n\x05\x04\"\x02\0\x04\x12\x04\xb5\x03\x04\x0c\n\r\n\x05\x04\"\x02\0\
    \x05\x12\x04\xb5\x03\r\x13\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xb5\x03\x14\
    \x17\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xb5\x03\x1a\x1b\n\x0c\n\x04\x04\"\
    \x02\x01\x12\x04\xb6\x03\x04\x1b\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xb6\
    \x03\x04\x0c\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xb6\x03\r\x13\n\r\n\x05\
    \x04\"\x02\x01\x01\x12\x04\xb6\x03\x14\x16\n\r\n\x05\x04\"\x02\x01\x03\
    \x12\x04\xb6\x03\x19\x1a\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xb7\x03\x04\
    \x1b\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\xb7\x03\x04\x0c\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\xb7\x03\r\x13\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \xb7\x03\x14\x16\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xb7\x03\x19\x1a\n\
    \x0c\n\x04\x04\"\x02\x03\x12\x04\xb8\x03\x04\x1b\n\r\n\x05\x04\"\x02\x03\
    \x04\x12\x04\xb8\x03\x04\x0c\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xb8\x03\
    \r\x13\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xb8\x03\x14\x16\n\r\n\x05\x04\
    \"\x02\x03\x03\x12\x04\xb8\x03\x19\x1a\n\x0c\n\x04\x04\"\x02\x04\x12\x04\
    \xb9\x03\x04\x1d\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\xb9\x03\x04\x0c\n\r\
    \n\x05\x04\"\x02\x04\x05\x12\x04\xb9\x03\r\x12\n\r\n\x05\x04\"\x02\x04\
    \x01\x12\x04\xb9\x03\x13\x18\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xb9\x03\
    \x1b\x1c\n\x0c\n\x04\x04\"\x02\x05\x12\x04\xba\x03\x04\x1d\n\r\n\x05\x04\
    \"\x02\x05\x04\x12\x04\xba\x03\x04\x0c\n\r\n\x05\x04\"\x02\x05\x05\x12\
    \x04\xba\x03\r\x12\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\xba\x03\x13\x18\n\
    \r\n\x05\x04\"\x02\x05\x03\x12\x04\xba\x03\x1b\x1c\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(44);
            messages.push(MoneroTransactionSourceEntry::generated_message_descriptor_data());
            messages.push(MoneroTransactionDestinationEntry::generated_message_descriptor_data());
            messages.push(MoneroTransactionRsigData::generated_message_descriptor_data());
            messages.push(MoneroGetAddress::generated_message_descriptor_data());
            messages.push(MoneroAddress::generated_message_descriptor_data());
            messages.push(MoneroGetWatchKey::generated_message_descriptor_data());
            messages.push(MoneroWatchKey::generated_message_descriptor_data());
            messages.push(MoneroTransactionInitRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionInitAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetInputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetInputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputsPermutationRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputsPermutationAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputViniRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputViniAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllInputsSetRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllInputsSetAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetOutputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetOutputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllOutSetRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllOutSetAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionMlsagDoneRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionMlsagDoneAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSignInputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSignInputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionFinalRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionFinalAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageExportInitRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageExportInitAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncStepRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncStepAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncFinalRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncFinalAck::generated_message_descriptor_data());
            messages.push(DebugMoneroDiagRequest::generated_message_descriptor_data());
            messages.push(DebugMoneroDiagAck::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::MoneroOutputEntry::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::MoneroMultisigKLRki::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::monero_output_entry::MoneroRctKey::generated_message_descriptor_data());
            messages.push(monero_transaction_destination_entry::MoneroAccountPublicAddress::generated_message_descriptor_data());
            messages.push(monero_transaction_init_request::MoneroTransactionData::generated_message_descriptor_data());
            messages.push(monero_transaction_all_out_set_ack::MoneroRingCtSig::generated_message_descriptor_data());
            messages.push(monero_key_image_export_init_request::MoneroSubAddressIndicesList::generated_message_descriptor_data());
            messages.push(monero_key_image_sync_step_request::MoneroTransferDetails::generated_message_descriptor_data());
            messages.push(monero_key_image_sync_step_ack::MoneroExportedKeyImage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
